/*
 * Copyright 2024-2025 Morse Micro
 * SPDX-License-Identifier: GPL-2.0-or-later
 *
 * Driver - Host Interface API
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 */

#ifndef _MORSE_COMMANDS_H_
#define _MORSE_COMMANDS_H_

#include <linux/types.h>

#define __sle16 __le16
#define __sle32 __le32
#define __sle64 __le64

#define MORSE_CMD_SEMVER_MAJOR	56
#define MORSE_CMD_SEMVER_MINOR	3
#define MORSE_CMD_SEMVER_PATCH	0

#define MORSE_CMD_TYPE_REQ	BIT(0)
#define MORSE_CMD_TYPE_RESP	BIT(1)
#define MORSE_CMD_TYPE_EVT	BIT(2)

#define MORSE_CMD_SSID_MAX_LEN	32
#define MORSE_CMD_MAC_ADDR_LEN	6

enum morse_cmd_id {
	/* Standard commands starting at 0x0000 */
	MORSE_CMD_ID_SET_CHANNEL		= 0x0001,
	MORSE_CMD_ID_GET_VERSION		= 0x0002,
	MORSE_CMD_ID_SET_TXPOWER		= 0x0003,
	MORSE_CMD_ID_ADD_INTERFACE		= 0x0004,
	MORSE_CMD_ID_REMOVE_INTERFACE		= 0x0005,
	MORSE_CMD_ID_BSS_CONFIG			= 0x0006,
	MORSE_CMD_ID_RPG			= 0x0009,
	MORSE_CMD_ID_INSTALL_KEY		= 0x000A,
	MORSE_CMD_ID_DISABLE_KEY		= 0x000B,
	MORSE_CMD_ID_SCAN_CONFIG		= 0x0010,
	MORSE_CMD_ID_SET_QOS_PARAMS		= 0x0011,
	MORSE_CMD_ID_GET_QOS_PARAMS		= 0x0012,
	MORSE_CMD_ID_GET_CHANNEL_FULL		= 0x0013,
	MORSE_CMD_ID_SET_STA_STATE		= 0x0014,
	MORSE_CMD_ID_SET_BSS_COLOR		= 0x0015,
	MORSE_CMD_ID_CONFIG_PS			= 0x0016,
	MORSE_CMD_ID_HEALTH_CHECK		= 0x0019,
	MORSE_CMD_ID_CTS_SELF_PS		= 0x001A,
	MORSE_CMD_ID_DTIM_CHANNEL_ENABLE	= 0x001B,
	MORSE_CMD_ID_GET_CHANNEL_DTIM		= 0x001C,
	MORSE_CMD_ID_GET_CHANNEL		= 0x001D,
	MORSE_CMD_ID_ARP_OFFLOAD		= 0x0020,
	MORSE_CMD_ID_SET_LONG_SLEEP_CONFIG	= 0x0021,
	MORSE_CMD_ID_SET_DUTY_CYCLE		= 0x0022,
	MORSE_CMD_ID_GET_DUTY_CYCLE		= 0x0023,
	MORSE_CMD_ID_GET_MAX_TXPOWER		= 0x0024,
	MORSE_CMD_ID_GET_CAPABILITIES		= 0x0025,
	MORSE_CMD_ID_TWT_AGREEMENT_INSTALL	= 0x0026,
	MORSE_CMD_ID_TWT_AGREEMENT_REMOVE	= 0x0027,
	MORSE_CMD_ID_GET_TSF			= 0x0028,
	MORSE_CMD_ID_MAC_ADDR			= 0x0029,
	MORSE_CMD_ID_MPSW_CONFIG		= 0x0030,
	MORSE_CMD_ID_STANDBY_MODE		= 0x0031,
	MORSE_CMD_ID_DHCP_OFFLOAD		= 0x0032,
	MORSE_CMD_ID_SET_KEEP_ALIVE_OFFLOAD	= 0x0033,
	MORSE_CMD_ID_UPDATE_OUI_FILTER		= 0x0034,
	MORSE_CMD_ID_IBSS_CONFIG		= 0x0035,
	MORSE_CMD_ID_TWT_AGREEMENT_VALIDATE	= 0x0036,
	MORSE_CMD_ID_OCS			= 0x0038,
	MORSE_CMD_ID_MESH_CONFIG		= 0x0039,
	MORSE_CMD_ID_SET_OFFSET_TSF		= 0x003A,
	MORSE_CMD_ID_GET_CHANNEL_USAGE		= 0x003B,
	MORSE_CMD_ID_MCAST_FILTER		= 0x003C,
	MORSE_CMD_ID_BSS_BEACON_CONFIG		= 0x003D,
	MORSE_CMD_ID_UAPSD_CONFIG		= 0x0040,
	MORSE_CMD_ID_PV1_STORE_HC		= 0x0041,
	MORSE_CMD_ID_PV1_RX_AMPDU_CONFIG	= 0x0042,
	MORSE_CMD_ID_PAGE_SLICING_CONFIG	= 0x0043,
	MORSE_CMD_ID_HW_SCAN			= 0x0044,
	MORSE_CMD_ID_SET_WHITELIST		= 0x0045,
	MORSE_CMD_ID_ARP_PERIODIC_REFRESH	= 0x0046,
	MORSE_CMD_ID_SET_TCP_KEEPALIVE		= 0x0047,
	MORSE_CMD_ID_FORCE_POWER_MODE		= 0x0048,
	MORSE_CMD_ID_LI_SLEEP			= 0x0049,
	MORSE_CMD_ID_GET_DISABLED_CHANNELS	= 0x004A,
	MORSE_CMD_ID_SET_CQM_RSSI		= 0x004F,
	MORSE_CMD_ID_GET_APF_CAPABILITIES	= 0x0050,
	MORSE_CMD_ID_READ_WRITE_APF		= 0x0051,

	/* Stats commands starting at 0x2000 */
	MORSE_CMD_ID_HOST_STATS_LOG		= 0x2007,
	MORSE_CMD_ID_HOST_STATS_RESET		= 0x2008,
	MORSE_CMD_ID_MAC_STATS_LOG		= 0x200C,
	MORSE_CMD_ID_MAC_STATS_RESET		= 0x200D,
	MORSE_CMD_ID_UPHY_STATS_LOG		= 0x200E,
	MORSE_CMD_ID_UPHY_STATS_RESET		= 0x200F,

	/* Driver commands starting at 0xA000 */
	MORSE_CMD_ID_DRIVER_START		= 0xA000,
	MORSE_CMD_ID_SET_STA_TYPE		= 0xA000,
	MORSE_CMD_ID_SET_ENC_MODE		= 0xA001,
	MORSE_CMD_ID_TEST_BA			= 0xA002,
	MORSE_CMD_ID_SET_LISTEN_INTERVAL	= 0xA003,
	MORSE_CMD_ID_SET_AMPDU			= 0xA004,
	MORSE_CMD_ID_COREDUMP			= 0xA006,
	MORSE_CMD_ID_SET_S1G_OP_CLASS		= 0xA007,
	MORSE_CMD_ID_SEND_WAKE_ACTION_FRAME	= 0xA008,
	MORSE_CMD_ID_VENDOR_IE_CONFIG		= 0xA009,
	MORSE_CMD_ID_SET_TWT_CONF		= 0xA010,
	MORSE_CMD_ID_GET_AVAILABLE_CHANNELS	= 0xA011,
	MORSE_CMD_ID_SET_ECSA_S1G_INFO		= 0xA012,
	MORSE_CMD_ID_GET_HW_VERSION		= 0xA013,
	MORSE_CMD_ID_CAC			= 0xA014,
	MORSE_CMD_ID_DRIVER_SET_DUTY_CYCLE	= 0xA015,
	MORSE_CMD_ID_MBSSID			= 0xA016,
	MORSE_CMD_ID_OCS_DRIVER			= 0xA017,
	MORSE_CMD_ID_SET_MESH_CONFIG		= 0xA018,
	MORSE_CMD_ID_SET_MCBA_CONF		= 0xA019,
	MORSE_CMD_ID_DYNAMIC_PEERING_CONFIG	= 0xA020,
	MORSE_CMD_ID_CONFIG_RAW			= 0xA021,
	MORSE_CMD_ID_CONFIG_BSS_STATS		= 0xA022,
	MORSE_CMD_ID_DRIVER_END,

	/* Fullmac commands starting at 0x0800 */
	MORSE_CMD_ID_START_SCAN			= 0x0801,
	MORSE_CMD_ID_ABORT_SCAN			= 0x0802,
	MORSE_CMD_ID_DISCONNECT			= 0x0804,
	MORSE_CMD_ID_GET_CONNECTION_STATE	= 0x0805,
	MORSE_CMD_ID_SET_RATE_CONTROL		= 0x0807,
	MORSE_CMD_ID_CONNECT			= 0x0808,

	/* Temporary commands starting at 0x1000 */
	MORSE_CMD_ID_GET_RSSI			= 0x1002,
	MORSE_CMD_ID_SET_IFS			= 0x1003,
	MORSE_CMD_ID_SET_FEM_SETTINGS		= 0x1005,
	MORSE_CMD_ID_SET_TXOP			= 0x1008,
	MORSE_CMD_ID_SET_CONTROL_RESPONSE	= 0x1009,
	MORSE_CMD_ID_SET_PERIODIC_CAL		= 0x100A,
	MORSE_CMD_ID_SET_BCN_RSSI_THRESHOLD	= 0x100B,
	MORSE_CMD_ID_SET_TX_PKT_LIFETIME_USECS	= 0x100C,
	MORSE_CMD_ID_SET_PHYSM_WATCHDOG		= 0x100D,
	MORSE_CMD_ID_TX_POLAR			= 0x100E,

	/* Events starting at 0x4000 */
	MORSE_CMD_ID_EVT_STA_STATE		= 0x4001,
	MORSE_CMD_ID_EVT_BEACON_LOSS		= 0x4002,
	MORSE_CMD_ID_EVT_SIG_FIELD_ERROR	= 0x4003,
	MORSE_CMD_ID_EVT_UMAC_TRAFFIC_CONTROL	= 0x4004,
	MORSE_CMD_ID_EVT_DHCP_LEASE_UPDATE	= 0x4005,
	MORSE_CMD_ID_EVT_OCS_DONE		= 0x4006,
	MORSE_CMD_ID_EVT_HW_SCAN_DONE		= 0x4011,
	MORSE_CMD_ID_EVT_CHANNEL_USAGE		= 0x4012,
	MORSE_CMD_ID_EVT_CONNECTION_LOSS	= 0x4013,
	MORSE_CMD_ID_EVT_SCHED_SCAN_RESULTS	= 0x4014,
	MORSE_CMD_ID_EVT_CQM_RSSI_NOTIFY	= 0x4015,

	/* Fullmac-specific events */
	MORSE_CMD_ID_EVT_SCAN_DONE		= 0x4007,
	MORSE_CMD_ID_EVT_SCAN_RESULT		= 0x4008,
	MORSE_CMD_ID_EVT_CONNECTED		= 0x4009,
	MORSE_CMD_ID_EVT_DISCONNECTED		= 0x4010,
	MORSE_CMD_ID_EVT_BEACON_FILTER_MATCH	= 0x4016,

	/* Test commands starting at 0x8000 */
	MORSE_CMD_ID_SET_TRANSMISSION_RATE	= 0x8009,
	MORSE_CMD_ID_SET_CAPABILITIES		= 0x8118,

	/* The get/set parameter command at 0x003E */
	MORSE_CMD_ID_GET_SET_GENERIC_PARAM	= 0x003E,

	/* Deprecated commands - do not use */
	MORSE_CMD_ID_HOST_STATS_LOG_DEPRECATED	= 0x0007,
	MORSE_CMD_ID_MAC_STATS_LOG_DEPRECATED	= 0x000C,
	MORSE_CMD_ID_UPHY_STATS_LOG_DEPRECATED	= 0x000E,
	MORSE_CMD_ID_BLOCKACK			= 0x0017,
	MORSE_CMD_ID_TURBO_MODE			= 0x0018,
	MORSE_CMD_ID_CFG_ACI_SCAN		= 0x001F,
	MORSE_CMD_ID_CONNECT_DEPRECATED		= 0x0803,
	MORSE_CMD_ID_SET_MODULATION		= 0x1000,
	MORSE_CMD_ID_START_SAMPLE_PLAY		= 0x8002,
	MORSE_CMD_ID_STOP_SAMPLE_PLAY		= 0x8003,
	MORSE_CMD_ID_SEND_PACKET_AS_AMPDU	= 0x8004,
	MORSE_CMD_ID_SET_MAC_ACK_TIMEOUT	= 0x8008,
	MORSE_CMD_ID_SPOOF_MANAGED_CALIBRATION	= 0x8010,
	MORSE_CMD_ID_SET_RAW_DEPRECATED		= 0xA005,
};

/**
 * MAC address structure
 */
struct morse_cmd_mac_addr {
	u8 octet[MORSE_CMD_MAC_ADDR_LEN];
};

/**
 * enum morse_cmd_ocs_subcmd - Subcommand values for OCS command
 */
enum morse_cmd_ocs_subcmd {
	MORSE_CMD_OCS_SUBCMD_CONFIG	= 1,
	MORSE_CMD_OCS_SUBCMD_STATUS	= 2,
};

/**
 * The header for a command
 * @flags: Flags - used between host and firmware
 * @message_id: Message id - from enum morse_commands_id
 * @len: Command length excluding the header
 * @host_id: Host sequence id - used between host and firmware only
 * @vif_id: Interface id - set by the host and copied into the response
 * @pad: Padding for word alignment
 */
struct morse_cmd_header {
	__le16 flags;
	__le16 message_id;
	__le16 len;
	__le16 host_id;
	__le16 vif_id;
	__le16 pad;
};

/**
 * Setting this value in the `SET_CHANNEL` command will cause the currently configured bandwidth to
 * be used.
 */
#define MORSE_CMD_CHANNEL_BW_NOT_SET 0xFF
/**
 * Setting this value in the `SET_CHANNEL` command will cause the currently configured channel index
 * to be used.
 */
#define MORSE_CMD_CHANNEL_IDX_NOT_SET 0xFF
/**
 * Setting this value in the `SET_CHANNEL` command will cause the currently configured frequency to
 * be used.
 */
#define MORSE_CMD_CHANNEL_FREQ_NOT_SET 0xFFFFFFFF

/**
 * enum morse_cmd_dot11_proto_mode - Used in setting dot11_mode in set_channel
 * @MORSE_CMD_DOT11_PROTO_MODE_AH: 802.11ah S1G mode
 * @MORSE_CMD_DOT11_PROTO_MODE_B: 802.11b (DSSS only) mode
 * @MORSE_CMD_DOT11_PROTO_MODE_BG: 802.11bg (Legacy only) mode
 * @MORSE_CMD_DOT11_PROTO_MODE_GN: 802.11gn (OFDM only) mode
 * @MORSE_CMD_DOT11_PROTO_MODE_BGN: 802.11bgn (Full compatibility) mode
 * @MORSE_CMD_DOT11_PROTO_MODE_INVALID: Invalid mode, PHY is not configured
 */
enum morse_cmd_dot11_proto_mode {
	MORSE_CMD_DOT11_PROTO_MODE_AH		= 0,
	MORSE_CMD_DOT11_PROTO_MODE_B		= 1,
	MORSE_CMD_DOT11_PROTO_MODE_BG		= 2,
	MORSE_CMD_DOT11_PROTO_MODE_GN		= 3,
	MORSE_CMD_DOT11_PROTO_MODE_BGN		= 4,
	MORSE_CMD_DOT11_PROTO_MODE_INVALID	= 5,
};

/**
 * struct morse_cmd_req_set_channel - request message for SET_CHANNEL
 * @op_chan_freq_hz: Center frequency of the operating channel
 * @op_bw_mhz: Operating channel bandwidth in MHz
 * @pri_bw_mhz: Primary channel bandwidth in MHz
 * @pri_1mhz_chan_idx: The index of the 1MHz channel within the operating channel. This is a value 0
 *                     for 1MHz channel, 0-1 for 2MHz, 0-3 for 4MHz, 0-7 for 8MHz and 0-15 for
 *                     16MHz.
 * @dot11_mode: enum morse_cmd_dot11_proto_mode
 * @reg_tx_power_set: Flag set to 1 to set the S1G TX power to the regulatory max, 0 to skip
 *                    setting. 1 by default. Used for debug on the driver only. Excluded from
 *                    firmware.
 *
 * In 802.11ah a BSS supports operating channel widths of 1, 2, 4, 8 and 16 MHz
 * and is required to use a 1MHz or 2MHz primary channel width.
 * Additionally 11ah requires that a 1MHz sub band channel must be available at all
 * operating channel widths regardless of the primary channel width.
 * The location of the 1MHz channel must be contained within the 1/2MHz primary channel.
 * The location of the 1MHz channel within the operating channel can be defined with
 * an integer index.
 *
 * For example, shown is an 8MHz operating channel with a 2MHz primary bandwidth
 * and the 1MHz channel at index 1:
 *
 * | <--------- 8MHz operating channel ----------> | Operating channel
 * | ----4MHz primary----- | ----4MHz secondary--- | 8MHz packet
 * | 2MHz Prim | 2MHz Sec  | --------------------- | 4MHz packet
 * | 2MHz Prim | --------------------------------- | 2MHz packet
 * | --- | 1MH | --------------------------------- | 1MHz packet
 *
 * | -0- | -1- | -2- | -3- | -4- | -5- | -6- | -7- | 1MHz Channel index
 * | ----0---- | ----1---- | ----2---- | ----3---- | 2MHz Channel index
 * | ----------0---------- | ----------1---------- | 4MHz Channel index
 * | ----------------------0---------------------- | 8MHz Channel index
 *
 * The index of the next higher sub band can be calculated by
 * floor(primary_1mhz_channel_index / sub_band_width).
 * E.g. if the 1MHz channel index is 3, the 2MHz primary is at floor(3/2) = 1
 */
struct morse_cmd_req_set_channel {
	struct morse_cmd_header hdr;
	__le32 op_chan_freq_hz;
	u8 op_bw_mhz;
	u8 pri_bw_mhz;
	u8 pri_1mhz_chan_idx;
	u8 dot11_mode;
	u8 reg_tx_power_set;
} __packed;

/**
 * struct morse_cmd_resp_set_channel - response message for SET_CHANNEL
 * @power_qdbm: Power in qdBm
 *
 * Returns the power of the channel set
 */
struct morse_cmd_resp_set_channel {
	struct morse_cmd_header hdr;
	__le32 status;
	__sle32 power_qdbm;
} __packed;

/**
 * struct morse_cmd_req_get_channel - request message for GET_CHANNEL
 *
 * Get the current channel from the firmware
 */
struct morse_cmd_req_get_channel {
	struct morse_cmd_header hdr;
} __packed;

/**
 * struct morse_cmd_resp_get_channel - response message for GET_CHANNEL
 * @op_chan_freq_hz: Centre frequency of the operating channel
 * @op_chan_bw_mhz: Operating channel bandwidth in MHz
 * @pri_chan_bw_mhz: Primary channel bandwidth in MHz
 * @pri_1mhz_chan_idx: The index of the 1MHz channel within the operating channel. This is a value 0
 *                     for 1MHz channel, 0-1 for 2MHz, 0-3 for 4MHz, 0-7 for 8MHz and 0-15 for
 *                     16MHz.
 *
 * Confirm message for get current channel
 */
struct morse_cmd_resp_get_channel {
	struct morse_cmd_header hdr;
	__le32 status;
	__le32 op_chan_freq_hz;
	u8 op_chan_bw_mhz;
	u8 pri_chan_bw_mhz;
	u8 pri_1mhz_chan_idx;
} __packed;

/** Maximum length of the version string */
#define MORSE_CMD_MAX_VERSION_LEN 128

/**
 * struct morse_cmd_req_get_version - request message for GET_VERSION
 */
struct morse_cmd_req_get_version {
	struct morse_cmd_header hdr;
} __packed;

/**
 * struct morse_cmd_resp_get_version - response message for GET_VERSION
 * @length: Length of version
 * @version: The version string. Variable length for the firmware. Use MORSE_CMD_MAX_VERSION_LEN to
 *           set size elsewhere.
 *
 * Structure for a get version confirm
 */
struct morse_cmd_resp_get_version {
	struct morse_cmd_header hdr;
	__le32 status;
	__sle32 length;
	u8 version[];
} __packed;

/**
 * struct morse_cmd_req_set_txpower - request message for SET_TXPOWER
 * @power_qdbm: Power in qdBm
 *
 * Set the transmit power in qdBm
 */
struct morse_cmd_req_set_txpower {
	struct morse_cmd_header hdr;
	__sle32 power_qdbm;
} __packed;

/**
 * struct morse_cmd_resp_set_txpower - response message for SET_TXPOWER
 * @power_qdbm: Power set in qdBm
 */
struct morse_cmd_resp_set_txpower {
	struct morse_cmd_header hdr;
	__le32 status;
	__sle32 power_qdbm;
} __packed;

/**
 * struct morse_cmd_req_get_max_txpower - request message for GET_MAX_TXPOWER
 *
 * Retrieve the maximum TX power that the chip can do
 */
struct morse_cmd_req_get_max_txpower {
	struct morse_cmd_header hdr;
} __packed;

/**
 * struct morse_cmd_resp_get_max_txpower - response message for GET_MAX_TXPOWER
 * @power_qdbm: Power in qdBm
 */
struct morse_cmd_resp_get_max_txpower {
	struct morse_cmd_header hdr;
	__le32 status;
	__sle32 power_qdbm;
} __packed;

/**
 * enum morse_cmd_interface_type - Different interface types
 * @MORSE_CMD_INTERFACE_TYPE_INVALID: An invalid interface type
 * @MORSE_CMD_INTERFACE_TYPE_STA: A station interface
 * @MORSE_CMD_INTERFACE_TYPE_AP: An access point interface
 * @MORSE_CMD_INTERFACE_TYPE_MON: A monitor mode interface
 * @MORSE_CMD_INTERFACE_TYPE_ADHOC: Independent BSS (IBSS) interface
 * @MORSE_CMD_INTERFACE_TYPE_MESH: Mesh interface
 * @MORSE_CMD_INTERFACE_TYPE_LAST: The last valid interface type
 */
enum morse_cmd_interface_type {
	MORSE_CMD_INTERFACE_TYPE_INVALID	= 0,
	MORSE_CMD_INTERFACE_TYPE_STA		= 1,
	MORSE_CMD_INTERFACE_TYPE_AP		= 2,
	MORSE_CMD_INTERFACE_TYPE_MON		= 3,
	MORSE_CMD_INTERFACE_TYPE_ADHOC		= 4,
	MORSE_CMD_INTERFACE_TYPE_MESH		= 5,
	MORSE_CMD_INTERFACE_TYPE_LAST		= MORSE_CMD_INTERFACE_TYPE_MESH,
};

/**
 * struct morse_cmd_req_add_interface - request message for ADD_INTERFACE
 * @addr: The address for the interface
 * @interface_type: The interface type
 */
struct morse_cmd_req_add_interface {
	struct morse_cmd_header hdr;
	struct morse_cmd_mac_addr addr;
	__le32 interface_type;
} __packed;

/**
 * struct morse_cmd_resp_add_interface - response message for ADD_INTERFACE
 */
struct morse_cmd_resp_add_interface {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_remove_interface - request message for REMOVE_INTERFACE
 */
struct morse_cmd_req_remove_interface {
	struct morse_cmd_header hdr;
} __packed;

/**
 * struct morse_cmd_resp_remove_interface - response message for REMOVE_INTERFACE
 */
struct morse_cmd_resp_remove_interface {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_bss_config - request message for BSS_CONFIG
 * @beacon_interval_tu: The beacon interval in TUs
 * @dtim_period: The DTIM period
 * @__padding: Padding to maintain aligned access
 * @cssid: The compressed ssid
 *
 * @note If this command is confirmed with status success, then the AP is active and firmware will
 * start to generate interrupts requesting a beacon
 */
struct morse_cmd_req_bss_config {
	struct morse_cmd_header hdr;
	__le16 beacon_interval_tu;
	__le16 dtim_period;
	u8 __padding[2];
	__le32 cssid;
} __packed;

/**
 * struct morse_cmd_resp_bss_config - response message for BSS_CONFIG
 */
struct morse_cmd_resp_bss_config {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * enum morse_cmd_rpg_id - RPG sub command IDs
 */
enum morse_cmd_rpg_id {
	MORSE_CMD_RPG_ID_START_TX		= 256,
	MORSE_CMD_RPG_ID_STOP_TX		= 257,
	MORSE_CMD_RPG_ID_GET_STATS		= 258,
	MORSE_CMD_RPG_ID_RESET_STATS		= 259,
	MORSE_CMD_RPG_ID_SET_SOURCE_ADDR	= 260,
	MORSE_CMD_RPG_ID_SET_DEST_ADDR		= 261,
	MORSE_CMD_RPG_ID_FORCE_AMPDU		= 262,
	MORSE_CMD_RPG_ID_FORCE_TX_RETRY		= 263,
};

/**
 *
 * @size: Size of RPG packets to be sent
 * @count: Number of RPG packets to send
 * @enable_random: Enable random packet data
 */
struct morse_cmd_rpg_start_tx {
	__sle32 size;
	__sle32 count;
	u8 enable_random;
} __packed;

/**
 * Set source mac address for RPG command
 */
struct morse_cmd_rpg_set_source_addr {
	struct morse_cmd_mac_addr source;
} __packed;

/**
 * Set destination mac address for RPG command
 */
struct morse_cmd_rpg_set_destination_addr {
	struct morse_cmd_mac_addr destination;
} __packed;

/**
 * Force the use of AMPDUs in RPG commands
 * @number: Maximum number of frames that can be aggregated
 */
struct morse_cmd_rpg_force_ampdu {
	__sle32 number;
} __packed;

/**
 * Force RPG tx retries
 * @bitmap: Bitmap of the MPDUs that should be failed, and re-aggregated
 */
struct morse_cmd_rpg_force_tx_retry {
	__le32 bitmap;
} __packed;

/**
 * Format of RPG statistics
 */
struct morse_cmd_rpg_stats {
	__le32 total_rx_packets;
	__le32 total_rx_packets_w_correct_fcs;
	__le32 total_tx_packets;
	__le32 rx_signal_field_errors;
} __packed;

/**
 * RPG statistics for morse_cmd_resp_rpg
 */
struct morse_cmd_rpg_resp_get_statistics {
	struct morse_cmd_rpg_stats stats;
} __packed;

/**
 * struct morse_cmd_req_rpg - request message for RPG
 * @sub_cmd: RPG subcommand @ref morse_cmd_rpg_id
 *
 * RPG shouldn't be enabled during normal driver operation
 */
struct morse_cmd_req_rpg {
	struct morse_cmd_header hdr;
	__le16 sub_cmd;
	union {
		u8 opaque[0];
		struct morse_cmd_rpg_start_tx start;
		struct morse_cmd_rpg_set_source_addr set_source;
		struct morse_cmd_rpg_set_destination_addr set_destination;
		struct morse_cmd_rpg_force_ampdu force_ampdu;
		struct morse_cmd_rpg_force_tx_retry force_tx_retry;
	};
} __packed;

/**
 * struct morse_cmd_resp_rpg - response message for RPG
 */
struct morse_cmd_resp_rpg {
	struct morse_cmd_header hdr;
	__le32 status;
	union {
		u8 opaque[0];
		struct morse_cmd_rpg_resp_get_statistics stats;
	};
} __packed;

/**
 * struct morse_cmd_req_scan_config - request message for SCAN_CONFIG
 * @enabled: MAC scan state
 * @is_survey: Will report noise level on each channel in the scan when set
 */
struct morse_cmd_req_scan_config {
	struct morse_cmd_header hdr;
	u8 enabled;
	u8 is_survey;
} __packed;

/**
 * struct morse_cmd_resp_scan_config - response message for SCAN_CONFIG
 */
struct morse_cmd_resp_scan_config {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_set_qos_params - request message for SET_QOS_PARAMS
 * @uapsd: U-APSD state for each QoS queue
 * @queue_idx: Index of the QoS queue whose values will be queried
 * @aifs_slot_count: How many slots to wait for AIFS
 * @contention_window_min: Contention window min value
 * @contention_window_max: Contention window max value
 * @max_txop_usec: Maximum possible TX OP in usec
 */
struct morse_cmd_req_set_qos_params {
	struct morse_cmd_header hdr;
	u8 uapsd;
	u8 queue_idx;
	u8 aifs_slot_count;
	__le16 contention_window_min;
	__le16 contention_window_max;
	__le32 max_txop_usec;
} __packed;

/**
 * struct morse_cmd_resp_set_qos_params - response message for SET_QOS_PARAMS
 */
struct morse_cmd_resp_set_qos_params {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_get_qos_params - request message for GET_QOS_PARAMS
 * @queue_idx: Index of the QoS queue whose values will be queried
 */
struct morse_cmd_req_get_qos_params {
	struct morse_cmd_header hdr;
	u8 queue_idx;
} __packed;

/**
 * struct morse_cmd_resp_get_qos_params - response message for GET_QOS_PARAMS
 * @aifs_slot_count: How many slots to wait for AIFS
 * @contention_window_min: Contention window min value
 * @contention_window_max: Contention window max value
 * @max_txop_usec: Maximum possible TX OP in usec
 */
struct morse_cmd_resp_get_qos_params {
	struct morse_cmd_header hdr;
	__le32 status;
	u8 aifs_slot_count;
	__le16 contention_window_min;
	__le16 contention_window_max;
	__le32 max_txop_usec;
} __packed;

/** STA Flag to notify PV1 */
#define MORSE_CMD_STA_FLAG_S1G_PV1 BIT(0)

/**
 * struct morse_cmd_req_set_sta_state - request message for SET_STA_STATE
 * @sta_addr: MAC address of the station
 * @aid: The STA association identifier
 * @state: Station IEEE80211 state @ref morse_cmd_ieee80211_sta_state
 * @uapsd_queues: U-APSD queues
 * @flags: Morse STA Flag @ref MORSE_CMD_STA_FLAG_S1G_PV1
 */
struct morse_cmd_req_set_sta_state {
	struct morse_cmd_header hdr;
	u8 sta_addr[MORSE_CMD_MAC_ADDR_LEN];
	__le16 aid;
	__le16 state;
	u8 uapsd_queues;
	__le32 flags;
} __packed;

/**
 * struct morse_cmd_resp_set_sta_state - response message for SET_STA_STATE
 */
struct morse_cmd_resp_set_sta_state {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_set_bss_color - request message for SET_BSS_COLOR
 * @bss_color: The BSS color
 */
struct morse_cmd_req_set_bss_color {
	struct morse_cmd_header hdr;
	u8 bss_color;
} __packed;

/**
 * struct morse_cmd_resp_set_bss_color - response message for SET_BSS_COLOR
 */
struct morse_cmd_resp_set_bss_color {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_config_ps - request message for CONFIG_PS
 * @enabled: When set to TRUE (1), MAC will start filtering beacons to allow chip to sleep
 */
struct morse_cmd_req_config_ps {
	struct morse_cmd_header hdr;
	u8 enabled;
	u8 dynamic_ps_offload;
} __packed;

/**
 * struct morse_cmd_resp_config_ps - response message for CONFIG_PS
 */
struct morse_cmd_resp_config_ps {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_health_check - request message for HEALTH_CHECK
 */
struct morse_cmd_req_health_check {
	struct morse_cmd_header hdr;
} __packed;

/**
 * struct morse_cmd_resp_health_check - response message for HEALTH_CHECK
 */
struct morse_cmd_resp_health_check {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_cts_self_ps - request message for CTS_SELF_PS
 *
 * Enable/disable CTS-to-self PS beacon mode
 */
struct morse_cmd_req_cts_self_ps {
	struct morse_cmd_header hdr;
	u8 enable;
} __packed;

/**
 * struct morse_cmd_resp_cts_self_ps - response message for CTS_SELF_PS
 */
struct morse_cmd_resp_cts_self_ps {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_dtim_channel_enable - request message for DTIM_CHANNEL_ENABLE
 *
 * Enable/disable DTIM channel switching
 */
struct morse_cmd_req_dtim_channel_enable {
	struct morse_cmd_header hdr;
	u8 enable;
} __packed;

/**
 * struct morse_cmd_resp_dtim_channel_enable - response message for DTIM_CHANNEL_ENABLE
 */
struct morse_cmd_resp_dtim_channel_enable {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/** Defined in mac80211 as IEEE80211_BSS_ARP_ADDR_LIST_LEN */
#define MORSE_CMD_ARP_OFFLOAD_MAX_IP_ADDRESSES 4

/**
 * struct morse_cmd_req_arp_offload - request message for ARP_OFFLOAD
 *
 * Update the ARP IP table used for ARP offloading/filtering and ICMP offload
 */
struct morse_cmd_req_arp_offload {
	struct morse_cmd_header hdr;
	__be32 ip_table[MORSE_CMD_ARP_OFFLOAD_MAX_IP_ADDRESSES];
} __packed;

/**
 * struct morse_cmd_resp_arp_offload - response message for ARP_OFFLOAD
 */
struct morse_cmd_resp_arp_offload {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_set_long_sleep_config - request message for SET_LONG_SLEEP_CONFIG
 * @enabled: Enable/disable long sleep
 *
 * @note This is used for WNM sleep to enable us to go deaf to traffic
 */
struct morse_cmd_req_set_long_sleep_config {
	struct morse_cmd_header hdr;
	u8 enabled;
} __packed;

/**
 * struct morse_cmd_resp_set_long_sleep_config - response message for SET_LONG_SLEEP_CONFIG
 */
struct morse_cmd_resp_set_long_sleep_config {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

#define MORSE_CMD_DUTY_CYCLE_SET_CFG_DUTY_CYCLE		BIT(0)
#define MORSE_CMD_DUTY_CYCLE_SET_CFG_OMIT_CONTROL_RESP	BIT(1)
#define MORSE_CMD_DUTY_CYCLE_SET_CFG_EXT		BIT(2)
#define MORSE_CMD_DUTY_CYCLE_SET_CFG_BURST_RECORD_UNIT	BIT(3)

/**
 * enum morse_cmd_duty_cycle_mode - Duty cycle mode of operation
 */
enum morse_cmd_duty_cycle_mode {
	MORSE_CMD_DUTY_CYCLE_MODE_SPREAD	= 0,
	MORSE_CMD_DUTY_CYCLE_MODE_BURST		= 1,
	MORSE_CMD_DUTY_CYCLE_MODE_LAST		= MORSE_CMD_DUTY_CYCLE_MODE_BURST,
};

/**
 * Set duty cycle configuration
 * @omit_control_responses: Omit control responses from duty cycle budget
 * @duty_cycle: Target duty cycle in 100th of a %, i.e. 1..10000
 */
struct morse_cmd_duty_cycle_configuration {
	u8 omit_control_responses;
	__le32 duty_cycle;
} __packed;

/**
 * Extension parameters for the duty cycle exit
 * @burst_record_unit_us: The length of each burst record in the window (usecs) - applicable in
 *                        burst mode only
 * @mode: Duty cycle mode, see @ref enum morse_cmd_duty_cycle_mode
 */
struct morse_cmd_duty_cycle_set_configuration_ext {
	__le32 burst_record_unit_us;
	u8 mode;
} __packed;

/**
 * Set duty cycle exit configuration
 * @airtime_remaining_us: Airtime remaining (us) - applicable in burst mode only
 * @burst_window_duration_us: Burst window duration (us) - applicable in burst mode only
 * @set: Extension parameters that are configured
 */
struct morse_cmd_duty_cycle_configuration_ext {
	__le32 airtime_remaining_us;
	__le32 burst_window_duration_us;
	struct morse_cmd_duty_cycle_set_configuration_ext set;
} __packed;

/**
 * struct morse_cmd_req_set_duty_cycle - request message for SET_DUTY_CYCLE
 */
struct morse_cmd_req_set_duty_cycle {
	struct morse_cmd_header hdr;
	struct morse_cmd_duty_cycle_configuration config;
	u8 set_cfgs;
	struct morse_cmd_duty_cycle_set_configuration_ext config_ext;
} __packed;

/**
 * struct morse_cmd_resp_get_duty_cycle - response message for GET_DUTY_CYCLE
 */
struct morse_cmd_resp_get_duty_cycle {
	struct morse_cmd_header hdr;
	__le32 status;
	struct morse_cmd_duty_cycle_configuration config;
	struct morse_cmd_duty_cycle_configuration_ext config_ext;
} __packed;

#define MORSE_CMD_SET_S1G_CAP_FLAGS		BIT(0)
#define MORSE_CMD_SET_S1G_CAP_AMPDU_MSS		BIT(1)
#define MORSE_CMD_SET_S1G_CAP_BEAM_STS		BIT(2)
#define MORSE_CMD_SET_S1G_CAP_NUM_SOUND_DIMS	BIT(3)
#define MORSE_CMD_SET_S1G_CAP_MAX_AMPDU_LEXP	BIT(4)
#define MORSE_CMD_SET_MORSE_CAP_MMSS_OFFSET	BIT(5)
#define MORSE_CMD_S1G_CAPABILITY_FLAGS_WIDTH	4

/**
 * MM firmware capabilities
 * @flags: Capability flags
 * @ampdu_mss: The minimum A-MPDU start spacing required by firmware
 * @beamformee_sts_capability: The beamformee STS capability value
 * @number_sounding_dimensions: Number of sounding dimensions
 * @maximum_ampdu_length_exponent: The maximum A-MPDU length. This is the exponent value such that
 *                                 (2^(13 + exponent) - 1) is the length.
 */
struct morse_cmd_mm_capabilities {
	__le32 flags[MORSE_CMD_S1G_CAPABILITY_FLAGS_WIDTH];
	u8 ampdu_mss;
	u8 beamformee_sts_capability;
	u8 number_sounding_dimensions;
	u8 maximum_ampdu_length_exponent;
} __packed;

/**
 * struct morse_cmd_req_get_capabilities - request message for GET_CAPABILITIES
 */
struct morse_cmd_req_get_capabilities {
	struct morse_cmd_header hdr;
} __packed;

/**
 * struct morse_cmd_resp_get_capabilities - response message for GET_CAPABILITIES
 * @morse_mmss_offset: Morse custom MMSS (Minimum MPDU Start Spacing) offset
 *
 * Get MM firmware capabilities
 */
struct morse_cmd_resp_get_capabilities {
	struct morse_cmd_header hdr;
	__le32 status;
	struct morse_cmd_mm_capabilities capabilities;
	u8 morse_mmss_offset;
} __packed;

#define MORSE_CMD_DOT11_TWT_AGREEMENT_MAX_LEN 20

/**
 * struct morse_cmd_req_twt_agreement_install - request message for TWT_AGREEMENT_INSTALL
 * @flow_id: The flow (TWT) identifier for this agreement
 * @agreement_len: The length of the TWT agreement
 * @agreement: The TWT agreement data
 */
struct morse_cmd_req_twt_agreement_install {
	struct morse_cmd_header hdr;
	u8 flow_id;
	u8 agreement_len;
	u8 agreement[MORSE_CMD_DOT11_TWT_AGREEMENT_MAX_LEN];
} __packed;

/**
 * struct morse_cmd_resp_twt_agreement_install - response message for TWT_AGREEMENT_INSTALL
 */
struct morse_cmd_resp_twt_agreement_install {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_twt_agreement_validate - request message for TWT_AGREEMENT_VALIDATE
 * @flow_id: The flow (TWT) identifier for this agreement
 * @agreement_len: The length of the TWT agreement
 * @agreement: The TWT agreement data
 */
struct morse_cmd_req_twt_agreement_validate {
	struct morse_cmd_header hdr;
	u8 flow_id;
	u8 agreement_len;
	u8 agreement[MORSE_CMD_DOT11_TWT_AGREEMENT_MAX_LEN];
} __packed;

/**
 * struct morse_cmd_resp_twt_agreement_validate - response message for TWT_AGREEMENT_VALIDATE
 */
struct morse_cmd_resp_twt_agreement_validate {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_twt_agreement_remove - request message for TWT_AGREEMENT_REMOVE
 * @flow_id: The flow (TWT) identifier for the agreement to remove
 *
 * Remove the TWT agreement at a given flow id
 */
struct morse_cmd_req_twt_agreement_remove {
	struct morse_cmd_header hdr;
	u8 flow_id;
} __packed;

/**
 * struct morse_cmd_req_get_tsf - request message for GET_TSF
 */
struct morse_cmd_req_get_tsf {
	struct morse_cmd_header hdr;
} __packed;

/**
 * struct morse_cmd_resp_get_tsf - response message for GET_TSF
 * @now_tsf: The current TSF of the BSS the interface is associated on
 * @now_chip_ts: Communicates the chip time used to derive the TSF (microseconds). The UMAC can use
 *               this field for precise TSF tracking.
 */
struct morse_cmd_resp_get_tsf {
	struct morse_cmd_header hdr;
	__le32 status;
	__le64 now_tsf;
	__le64 now_chip_ts;
} __packed;

/**
 * struct morse_cmd_req_mac_addr - request message for MAC_ADDR
 */
struct morse_cmd_req_mac_addr {
	struct morse_cmd_header hdr;
	u8 write;
	u8 octet[MORSE_CMD_MAC_ADDR_LEN];
} __packed;

/**
 * struct morse_cmd_resp_mac_addr - response message for MAC_ADDR
 */
struct morse_cmd_resp_mac_addr {
	struct morse_cmd_header hdr;
	__le32 status;
	u8 octet[MORSE_CMD_MAC_ADDR_LEN];
} __packed;

#define MORSE_CMD_SET_MPSW_CFG_AIRTIME_BOUNDS	BIT(0)
#define MORSE_CMD_SET_MPSW_CFG_PKT_SPC_WIN_LEN	BIT(1)
#define MORSE_CMD_SET_MPSW_CFG_ENABLED		BIT(2)

/**
 * MPSW configuration structure
 * @airtime_max_us: The maximum allowable packet airtime duration
 * @airtime_min_us: The minimum packet airtime duration to trigger spacing
 * @packet_space_window_length_us: The length of time to close the tx window between packets
 * @enable: Whether to enable airtime bounds checking and packet spacing enforcement
 */
struct morse_cmd_mpsw_configuration {
	__le32 airtime_max_us;
	__le32 airtime_min_us;
	__le32 packet_space_window_length_us;
	u8 enable;
} __packed;

/**
 * struct morse_cmd_req_mpsw_config - request message for MPSW_CONFIG
 */
struct morse_cmd_req_mpsw_config {
	struct morse_cmd_header hdr;
	struct morse_cmd_mpsw_configuration config;
	u8 set_cfgs;
} __packed;

/**
 * struct morse_cmd_resp_mpsw_config - response message for MPSW_CONFIG
 */
struct morse_cmd_resp_mpsw_config {
	struct morse_cmd_header hdr;
	__le32 status;
	struct morse_cmd_mpsw_configuration config;
} __packed;

/** Keys are up to 32 bytes in length */
#define MORSE_CMD_MAX_KEY_LEN 32

/**
 * enum morse_cmd_key_cipher - Different key cipher types
 */
enum morse_cmd_key_cipher {
	MORSE_CMD_KEY_CIPHER_INVALID	= 0,
	MORSE_CMD_KEY_CIPHER_AES_CCM	= 1,
	MORSE_CMD_KEY_CIPHER_AES_GCM	= 2,
	MORSE_CMD_KEY_CIPHER_AES_CMAC	= 3,
	MORSE_CMD_KEY_CIPHER_AES_GMAC	= 4,
	MORSE_CMD_KEY_CIPHER_LAST	= MORSE_CMD_KEY_CIPHER_AES_GMAC,
};

/**
 * enum morse_cmd_aes_key_len - Different aes key lengths
 */
enum morse_cmd_aes_key_len {
	MORSE_CMD_AES_KEY_LEN_INVALID		= 0,
	MORSE_CMD_AES_KEY_LEN_LENGTH_128	= 1,
	MORSE_CMD_AES_KEY_LEN_LENGTH_256	= 2,
	MORSE_CMD_AES_KEY_LEN_LENGTH_LAST	= MORSE_CMD_AES_KEY_LEN_LENGTH_256,
};

/**
 * enum morse_cmd_temporal_key_type - Different temporal key types
 */
enum morse_cmd_temporal_key_type {
	MORSE_CMD_TEMPORAL_KEY_TYPE_INVALID	= 0,
	MORSE_CMD_TEMPORAL_KEY_TYPE_GTK		= 1,
	MORSE_CMD_TEMPORAL_KEY_TYPE_PTK		= 2,
	MORSE_CMD_TEMPORAL_KEY_TYPE_IGTK	= 3,
	MORSE_CMD_TEMPORAL_KEY_TYPE_LAST	= MORSE_CMD_TEMPORAL_KEY_TYPE_IGTK,
};

/**
 * struct morse_cmd_req_install_key - request message for INSTALL_KEY
 * @pn: The packet number to start from
 * @aid: AID for the station to install. Set to 0 if this is for an AP
 * @key_idx: The key index (0-3) maps to Linux key index
 * @cipher: The key cipher @ref morse_cmd_key_cipher
 * @key_length: The length of the aes key @ref morse_cmd_aes_key_length
 * @key_type: The temporal key type @ref morse_cmd_temporal_key_type
 * @__padding: Padding for word aligned access to the key
 * @key: The key
 *
 * Installs a key for encryption
 */
struct morse_cmd_req_install_key {
	struct morse_cmd_header hdr;
	__le64 pn;
	__le32 aid;
	u8 key_idx;
	u8 cipher;
	u8 key_length;
	u8 key_type;
	u8 __padding[2];
	u8 key[MORSE_CMD_MAX_KEY_LEN];
} __packed;

/**
 * struct morse_cmd_resp_install_key - response message for INSTALL_KEY
 * @key_idx: The index to which the key was installed
 */
struct morse_cmd_resp_install_key {
	struct morse_cmd_header hdr;
	__le32 status;
	u8 key_idx;
} __packed;

/**
 * struct morse_cmd_req_disable_key - request message for DISABLE_KEY
 * @key_type: The temporal key type @ref morse_cmd_temporal_key_type
 * @aid: AID for the station to install. Set to 0 if this is for an AP.
 * @key_idx: The key index maps to index in chip
 */
struct morse_cmd_req_disable_key {
	struct morse_cmd_header hdr;
	__le32 key_type;
	__le32 aid;
	u8 key_idx;
} __packed;

/**
 * struct morse_cmd_resp_disable_key - response message for DISABLE_KEY
 */
struct morse_cmd_resp_disable_key {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/** The maximum length of a user-specified payload (bytes) for Standby status frames */
#define MORSE_CMD_STANDBY_STATUS_FRAME_USER_PAYLOAD_MAX_LEN 64
/** The maximum allowed length of a user filter to apply to wake frames */
#define MORSE_CMD_STANDBY_WAKE_FRAME_USER_FILTER_MAX_LEN 64

/**
 * enum morse_cmd_standby_mode - Return codes for standby mode commands
 * @MORSE_CMD_STANDBY_MODE_EXIT: The external host is indicating that it's now awake
 * @MORSE_CMD_STANDBY_MODE_ENTER: The external host is indicating that it's going into standby mode
 * @MORSE_CMD_STANDBY_MODE_SET_CONFIG_V1: This version of the config command has since been
 *                                        deprecated (see v3 below)
 * @MORSE_CMD_STANDBY_MODE_SET_STATUS_PAYLOAD: The external host provides a payload that gets
 *                                             appended to status frames
 * @MORSE_CMD_STANDBY_MODE_SET_WAKE_FILTER: The external host provides a filter to be applied to
 *                                          incoming standby wake frames
 * @MORSE_CMD_STANDBY_MODE_SET_CONFIG_V2: This version of the config command has since been
 *                                        deprecated (see v3 below)
 * @MORSE_CMD_STANDBY_MODE_SET_CONFIG_V3: The external host sets a number of configuration options
 *                                        for standby mode
 */
enum morse_cmd_standby_mode {
	MORSE_CMD_STANDBY_MODE_EXIT			= 0,
	MORSE_CMD_STANDBY_MODE_ENTER			= 1,
	MORSE_CMD_STANDBY_MODE_SET_CONFIG_V1		= 2,
	MORSE_CMD_STANDBY_MODE_SET_STATUS_PAYLOAD	= 3,
	MORSE_CMD_STANDBY_MODE_SET_WAKE_FILTER		= 4,
	MORSE_CMD_STANDBY_MODE_SET_CONFIG_V2		= 5,
	MORSE_CMD_STANDBY_MODE_SET_CONFIG_V3		= 6,
};

/**
 * enum morse_cmd_standby_mode_exit_reason - Reason for standby mode exit
 * @MORSE_CMD_STANDBY_MODE_EXIT_REASON_NONE: No specific reason for exiting standby mode
 * @MORSE_CMD_STANDBY_MODE_EXIT_REASON_WAKEUP_FRAME: The STA has received the wakeup frame
 * @MORSE_CMD_STANDBY_MODE_EXIT_REASON_ASSOCIATE: The STA needs to (re)associate
 * @MORSE_CMD_STANDBY_MODE_EXIT_REASON_EXT_INPUT: The STA's external input pin has fired
 * @MORSE_CMD_STANDBY_MODE_EXIT_REASON_WHITELIST_PKT: Whitelisted packet received
 * @MORSE_CMD_STANDBY_MODE_EXIT_REASON_TCP_CONNECTION_LOST: TCP connection lost
 * @MORSE_CMD_STANDBY_MODE_EXIT_REASON_HW_SCAN_NOT_ENABLED: HW scan is not enabled
 * @MORSE_CMD_STANDBY_MODE_EXIT_REASON_HW_SCAN_FAILED_TO_START: HW scan failed to start
 * @MORSE_CMD_STANDBY_MODE_EXIT_REASON_MAX: Max exit reason enum value
 */
enum morse_cmd_standby_mode_exit_reason {
	MORSE_CMD_STANDBY_MODE_EXIT_REASON_NONE				= 0,
	MORSE_CMD_STANDBY_MODE_EXIT_REASON_WAKEUP_FRAME			= 1,
	MORSE_CMD_STANDBY_MODE_EXIT_REASON_ASSOCIATE			= 2,
	MORSE_CMD_STANDBY_MODE_EXIT_REASON_EXT_INPUT			= 3,
	MORSE_CMD_STANDBY_MODE_EXIT_REASON_WHITELIST_PKT		= 4,
	MORSE_CMD_STANDBY_MODE_EXIT_REASON_TCP_CONNECTION_LOST		= 5,
	MORSE_CMD_STANDBY_MODE_EXIT_REASON_HW_SCAN_NOT_ENABLED		= 6,
	MORSE_CMD_STANDBY_MODE_EXIT_REASON_HW_SCAN_FAILED_TO_START	= 7,
	MORSE_CMD_STANDBY_MODE_EXIT_REASON_MAX				=
		MORSE_CMD_STANDBY_MODE_EXIT_REASON_HW_SCAN_FAILED_TO_START,
};

/**
 * enum morse_cmd_ieee80211_sta_state - IEEE80211 Station State
 */
enum morse_cmd_ieee80211_sta_state {
	MORSE_CMD_IEEE80211_STA_STATE_NOTEXIST		= 0,
	MORSE_CMD_IEEE80211_STA_STATE_NONE		= 1,
	MORSE_CMD_IEEE80211_STA_STATE_AUTHENTICATED	= 2,
	MORSE_CMD_IEEE80211_STA_STATE_ASSOCIATED	= 3,
	MORSE_CMD_IEEE80211_STA_STATE_AUTHORIZED	= 4,
	MORSE_CMD_IEEE80211_STA_STATE_AUTHORIZED_ASLEEP = 5,
};

/**
 * Standby configuration structure
 * @notify_period_s: Interval for transmitting Standby status packets
 * @bss_inactivity_before_deep_sleep_s: Period of inactivity (traffic directed to STA) before
 *                                      external host triggers standby mode
 * @deep_sleep_period_s: Time for firmware to remain in deep sleep in seconds
 * @src_ip: Source IP address
 * @dst_ip: Destination IP address
 * @dst_port: Destination UDP port
 * @pad: Padding for word aligned access in config. (It may grow in future)
 * @deep_sleep_increment_s: Time in seconds to increment each successive deep sleep
 * @deep_sleep_max_s: Max time to deep sleep for
 * @deep_sleep_scan_iterations: Number of deep sleeps iterations between scans
 */
struct morse_cmd_standby_set_config {
	__le32 notify_period_s;
	__le32 bss_inactivity_before_deep_sleep_s;
	__le32 deep_sleep_period_s;
	__le32 src_ip;
	__le32 dst_ip;
	__le16 dst_port;
	u8 pad[2];
	__le32 deep_sleep_increment_s;
	__le32 deep_sleep_max_s;
	__le32 deep_sleep_scan_iterations;
} __packed;

/**
 * Set standby mode status payload structure
 * @len: The length of the payload
 * @payload: The payload
 */
struct morse_cmd_standby_set_status_payload {
	__le32 len;
	u8 payload[MORSE_CMD_STANDBY_STATUS_FRAME_USER_PAYLOAD_MAX_LEN];
} __packed;

/**
 * Set standby mode enter structure
 * @monitor_bssid: The BSSID to monitor for activity (or lack thereof) before entering deep sleep
 */
struct morse_cmd_standby_enter {
	struct morse_cmd_mac_addr monitor_bssid;
} __packed;

/**
 * Set standby mode wake filter structure
 * @len: The length of the wake filter
 * @offset: The offset at which to apply the wake filter
 * @filter: The user-defined filter
 */
struct morse_cmd_standby_set_wake_filter {
	__le32 len;
	__le32 offset;
	u8 filter[MORSE_CMD_STANDBY_WAKE_FRAME_USER_FILTER_MAX_LEN];
} __packed;

/**
 * Standby mode exit response structure
 * @reason: Reason for exiting Standby mode, see @ref morse_cmd_standby_mode_exit_reason
 * @sta_state: Current connection state
 */
struct morse_cmd_standby_mode_exit {
	u8 reason;
	u8 sta_state;
} __packed;

/**
 * struct morse_cmd_req_standby_mode - request message for STANDBY_MODE
 * @cmd: Standby Mode subcommands, see @ref morse_cmd_standby_mode
 * @config: Valid for MORSE_CMD_STANDBY_MODE_SET_CONFIG cmd
 * @set_payload: Valid for MORSE_CMD_STANDBY_MODE_SET_STATUS_PAYLOAD cmd
 * @enter: Valid for MORSE_CMD_STANDBY_MODE_ENTER cmd
 * @set_filter: Valid for MORSE_CMD_STANDBY_MODE_SET_WAKE_FILTER cmd
 *
 * Structure for Configuring MM standby mode
 */
struct morse_cmd_req_standby_mode {
	struct morse_cmd_header hdr;
	__le32 cmd;
	union {
		u8 opaque[0];
		struct morse_cmd_standby_set_config config;
		struct morse_cmd_standby_set_status_payload set_payload;
		struct morse_cmd_standby_enter enter;
		struct morse_cmd_standby_set_wake_filter set_filter;
	};
} __packed;

/**
 * struct morse_cmd_resp_standby_mode - response message for STANDBY_MODE
 *
 * Response structure for MM standby mode command. For status, see @ref morse_cmd_standby_mode.
 */
struct morse_cmd_resp_standby_mode {
	struct morse_cmd_header hdr;
	__le32 status;
	union {
		u8 opaque[0];
		struct morse_cmd_standby_mode_exit info;
	};
} __packed;

/**
 * enum morse_cmd_dhcp_opcode - Opcode for DHCP client command
 * @MORSE_CMD_DHCP_OPCODE_ENABLE: Enable the DHCP client
 * @MORSE_CMD_DHCP_OPCODE_DO_DISCOVERY: Do a DHCP discovery and obtain a lease
 * @MORSE_CMD_DHCP_OPCODE_GET_LEASE: Return the current lease
 * @MORSE_CMD_DHCP_OPCODE_CLEAR_LEASE: Clear the current lease
 * @MORSE_CMD_DHCP_OPCODE_RENEW_LEASE: Trigger a renewal of the current lease
 * @MORSE_CMD_DHCP_OPCODE_REBIND_LEASE: Trigger a rebinding of the current lease
 * @MORSE_CMD_DHCP_OPCODE_SEND_LEASE_UPDATE: Ask the FW to send a lease update event to the driver
 */
enum morse_cmd_dhcp_opcode {
	MORSE_CMD_DHCP_OPCODE_ENABLE		= 0,
	MORSE_CMD_DHCP_OPCODE_DO_DISCOVERY	= 1,
	MORSE_CMD_DHCP_OPCODE_GET_LEASE		= 2,
	MORSE_CMD_DHCP_OPCODE_CLEAR_LEASE	= 3,
	MORSE_CMD_DHCP_OPCODE_RENEW_LEASE	= 4,
	MORSE_CMD_DHCP_OPCODE_REBIND_LEASE	= 5,
	MORSE_CMD_DHCP_OPCODE_SEND_LEASE_UPDATE = 6,
};

/**
 * enum morse_cmd_dhcp_retcode - Return codes for DHCP client command.
 * @MORSE_CMD_DHCP_RETCODE_SUCCESS: Command completed successfully
 * @MORSE_CMD_DHCP_RETCODE_NOT_ENABLED: DHCP Client is disabled
 * @MORSE_CMD_DHCP_RETCODE_ALREADY_ENABLED: DHCP Client is already enabled
 * @MORSE_CMD_DHCP_RETCODE_NO_LEASE: No current bound lease
 * @MORSE_CMD_DHCP_RETCODE_HAVE_LEASE: DHCP client already has a lease
 * @MORSE_CMD_DHCP_RETCODE_BUSY: DHCP client is currently busy (discovering or renewing)
 * @MORSE_CMD_DHCP_RETCODE_BAD_VIF: Invalid vif specified
 */
enum morse_cmd_dhcp_retcode {
	MORSE_CMD_DHCP_RETCODE_SUCCESS		= 0,
	MORSE_CMD_DHCP_RETCODE_NOT_ENABLED	= 1,
	MORSE_CMD_DHCP_RETCODE_ALREADY_ENABLED	= 2,
	MORSE_CMD_DHCP_RETCODE_NO_LEASE		= 3,
	MORSE_CMD_DHCP_RETCODE_HAVE_LEASE	= 4,
	MORSE_CMD_DHCP_RETCODE_BUSY		= 5,
	MORSE_CMD_DHCP_RETCODE_BAD_VIF		= 6,
};

/**
 * struct morse_cmd_req_dhcp_offload - request message for DHCP_OFFLOAD
 * @opcode: Opcode of command
 */
struct morse_cmd_req_dhcp_offload {
	struct morse_cmd_header hdr;
	__le32 opcode;
} __packed;

/**
 * struct morse_cmd_resp_dhcp_offload - response message for DHCP_OFFLOAD
 * @retcode: Return code of command
 * @my_ip: My leased IP address if command opcode was GET_LEASE
 * @netmask: My leased netmask if command opcode was GET_LEASE
 * @router: My leased router address if command opcode was GET_LEASE
 * @dns: Upstream DNS server if command opcode was GET_LEASE
 */
struct morse_cmd_resp_dhcp_offload {
	struct morse_cmd_header hdr;
	__le32 status;
	__le32 retcode;
	__le32 my_ip;
	__le32 netmask;
	__le32 router;
	__le32 dns;
} __packed;

/**
 * struct morse_cmd_req_set_keep_alive_offload - request message for SET_KEEP_ALIVE_OFFLOAD
 * @bss_max_idle_period: The value of the BSS max idle period as it appears in the IE
 * @interpret_as_11ah: Set to TRUE to interpret the value of BSS max idle period as per 11ah spec
 */
struct morse_cmd_req_set_keep_alive_offload {
	struct morse_cmd_header hdr;
	__le16 bss_max_idle_period;
	u8 interpret_as_11ah;
} __packed;

#define MORSE_CMD_MAX_OUI_FILTERS		5
#define MORSE_CMD_OUI_SIZE			3
#define MORSE_CMD_MAX_OUI_FILTER_ARRAY_SIZE	15

/**
 * struct morse_cmd_req_update_oui_filter - request message for UPDATE_OUI_FILTER
 */
struct morse_cmd_req_update_oui_filter {
	struct morse_cmd_header hdr;
	u8 n_ouis;
	u8 ouis[MORSE_CMD_MAX_OUI_FILTERS][MORSE_CMD_OUI_SIZE];
} __packed;

/**
 * enum morse_cmd_ibss_config_opcode - IBSS opcode for configuring the current state in firmware
 * @MORSE_CMD_IBSS_CONFIG_OPCODE_CREATE: IBSS creator mode
 */
enum morse_cmd_ibss_config_opcode {
	MORSE_CMD_IBSS_CONFIG_OPCODE_CREATE	= 0,
	MORSE_CMD_IBSS_CONFIG_OPCODE_JOIN	= 1,
	MORSE_CMD_IBSS_CONFIG_OPCODE_STOP	= 2,
};

/**
 * struct morse_cmd_req_ibss_config - request message for IBSS_CONFIG
 * @ibss_bssid: BSSID of IBSS (generated randomly in mac80211), this is not same as interface MAC
 *              addr
 * @ibss_cfg_opcode: IBSS opcode for configuring the current state @ref
 *                   morse_cmd_ibss_config_opcode. If CREATE is sent, then firmware will start to
 *                   generate interrupts. If JOIN is sent, then firmware will wait till we receive
 *                   beacon from IBSS network, then set its TSF and start the beacon timer to be in
 *                   sync with network TBTT. If CMD_STOP is sent, all the parameters will be cleared
 *                   in target and stop beaconing.
 * @ibss_probe_filtering: Probe request filtering based on the last beacon tx is handled in fw. When
 *                        set to 1, probe requests will be dropped in firmware, if this node didn't
 *                        transmit the last beacon. Otherwise, all the probe req will be forwarded
 *                        to host driver for responding with probe resp.
 *
 * @note This command is to configure IBSS parameters like BSSID and others
 */
struct morse_cmd_req_ibss_config {
	struct morse_cmd_header hdr;
	u8 ibss_bssid[MORSE_CMD_MAC_ADDR_LEN];
	u8 ibss_cfg_opcode;
	u8 ibss_probe_filtering;
} __packed;

/**
 * enum morse_cmd_ocs_type - OCS type
 */
enum morse_cmd_ocs_type {
	MORSE_CMD_OCS_TYPE_QNULL	= 0,
	MORSE_CMD_OCS_TYPE_RAW		= 1,
};

/**
 * Command request structure for OCS commands to the firmware
 * @type: OCS type @ref morse_cmd_ocs_type
 */
struct morse_cmd_ocs_config_req {
	__le32 op_channel_freq_hz;
	u8 op_channel_bw_mhz;
	u8 pri_channel_bw_mhz;
	u8 pri_1mhz_channel_index;
	__le16 aid;
	u8 type;
} __packed;

/**
 * Command response structure for OCS commands to the firmware
 */
struct morse_cmd_ocs_status_resp {
	u8 running;
} __packed;

/**
 * struct morse_cmd_req_ocs - request message for OCS
 * @subcmd: Subcommand value @ref morse_cmd_ocs_subcmd
 */
struct morse_cmd_req_ocs {
	struct morse_cmd_header hdr;
	__le32 subcmd;
	union {
		u8 opaque[0];
		struct morse_cmd_ocs_config_req config;
	};
} __packed;

/**
 * struct morse_cmd_resp_ocs - response message for OCS
 * @subcmd: Subcommand value @ref morse_cmd_ocs_subcmd
 */
struct morse_cmd_resp_ocs {
	struct morse_cmd_header hdr;
	__le32 status;
	__le32 subcmd;
	union {
		u8 opaque[0];
		struct morse_cmd_ocs_status_resp ocs_status;
	};
} __packed;

/**
 * enum morse_cmd_mesh_config_opcode - Mesh config command opcode for configuring the mesh interface
 * in firmware
 */
enum morse_cmd_mesh_config_opcode {
	MORSE_CMD_MESH_CONFIG_OPCODE_START	= 0,
	MORSE_CMD_MESH_CONFIG_OPCODE_STOP	= 1,
};

/**
 * struct morse_cmd_req_mesh_config - request message for MESH_CONFIG
 * @mesh_cfg_opcode: The mesh command operation code @ref morse_cmd_mesh_config_opcode. If
 *                   OPCODE_START is sent, then firmware will start to generate interrupts. If
 *                   OPCODE_STOP is sent, all the parameters will be cleared in target and stop
 *                   beaconing.
 * @enable_beaconing: Flag to enable/disable beaconing
 * @mbca_config: Configuration to enable/disable MBCA TBTT Selection and Adjustment
 * @min_beacon_gap_ms: Minimum gap between our beacons and neighbour beacons
 * @mbss_start_scan_duration_ms: Duration of the scan during start of the MBSS in milliseconds
 * @tbtt_adj_timer_interval_ms: TBTT adjustment timer interval in milliseconds
 *
 * @note This command is to configure Mesh specific parameters to firmware.
 */
struct morse_cmd_req_mesh_config {
	struct morse_cmd_header hdr;
	u8 mesh_cfg_opcode;
	u8 enable_beaconing;
	u8 mbca_config;
	u8 min_beacon_gap_ms;
	__le16 mbss_start_scan_duration_ms;
	__le16 tbtt_adj_timer_interval_ms;
} __packed;

/**
 * struct morse_cmd_req_set_offset_tsf - request message for SET_OFFSET_TSF
 * @offset_tsf: TSF offset to adjust for mesh interface
 *
 * Configure TSF offset for neighbor synchronization method in a mesh network. A mesh STA will use
 * the neighbor offset synchronization method as its active synchronization method, and maintain the
 * timing offset value between its own TSF timer and the TSF timer of each neighbor STA with which
 * it synchronizes. The mesh STA adjusts its TSF so that its TSF counting is aligned to the most
 * delayed neighbor STA.
 */
struct morse_cmd_req_set_offset_tsf {
	struct morse_cmd_header hdr;
	__sle64 offset_tsf;
} __packed;

/**
 * struct morse_cmd_req_get_channel_usage - request message for GET_CHANNEL_USAGE
 */
struct morse_cmd_req_get_channel_usage {
	struct morse_cmd_header hdr;
} __packed;

/**
 * struct morse_cmd_resp_get_channel_usage - response message for GET_CHANNEL_USAGE
 */
struct morse_cmd_resp_get_channel_usage {
	struct morse_cmd_header hdr;
	__le32 status;
	__le64 time_listen;
	__le64 busy_time;
	__le32 freq_hz;
	s8 noise;
	u8 bw_mhz;
} __packed;

#define MORSE_CMD_MAX_MCAST_FILTERS 12

/**
 * struct morse_cmd_req_mcast_filter - request message for MCAST_FILTER
 */
struct morse_cmd_req_mcast_filter {
	struct morse_cmd_header hdr;
	u8 count;
	__le32 hw_addr[];
} __packed;

/**
 * struct morse_cmd_req_bss_beacon_config - request message for BSS_BEACON_CONFIG
 * @enable: 1 to enable beaconing or 0 to disable
 *
 * Enable or disable beacon timer
 */
struct morse_cmd_req_bss_beacon_config {
	struct morse_cmd_header hdr;
	u8 enable;
} __packed;

/**
 * struct morse_cmd_resp_bss_beacon_config - response message for BSS_BEACON_CONFIG
 * @interface_id: The interface ID that is to be configured
 */
struct morse_cmd_resp_bss_beacon_config {
	struct morse_cmd_header hdr;
	__le32 status;
	__le16 interface_id;
} __packed;

/**
 * struct morse_cmd_req_uapsd_config - request message for UAPSD_CONFIG
 * @auto_trigger_enabled: Auto trigger enabled/disabled flag
 * @auto_trigger_timeout: Timeout(ms) at which frame is triggered
 */
struct morse_cmd_req_uapsd_config {
	struct morse_cmd_header hdr;
	u8 auto_trigger_enabled;
	__le32 auto_trigger_timeout;
} __packed;

/**
 * struct morse_cmd_resp_uapsd_config - response message for UAPSD_CONFIG
 * @auto_trigger_enabled: Confirm auto trigger enabled/disabled
 */
struct morse_cmd_resp_uapsd_config {
	struct morse_cmd_header hdr;
	__le32 status;
	u8 auto_trigger_enabled;
} __packed;

#define MORSE_CMD_PV1_STORE_A3	BIT(0)
#define MORSE_CMD_PV1_STORE_A4	BIT(1)
#define MORSE_CMD_PV1_STORE_RX	BIT(2)

/**
 * enum morse_cmd_pv1_hc_opcode - PV1 opcode for storing param from header compression
 */
enum morse_cmd_pv1_hc_opcode {
	MORSE_CMD_PV1_HC_OPCODE_A3_A4 = 0,
};

/**
 * struct morse_cmd_req_pv1_store_hc - request message for PV1_STORE_HC
 * @opcode: Address/CCMP update selection
 * @pv1_hc_store: Subfield flags bit mapped from Header Compression Request
 * @sta_addr: STA interface address
 * @a3: A3 address if A3 subfield is set
 * @a4: A4 address if A4 subfield is set
 */
struct morse_cmd_req_pv1_store_hc {
	struct morse_cmd_header hdr;
	u8 opcode;
	u8 pv1_hc_store;
	u8 sta_addr[MORSE_CMD_MAC_ADDR_LEN];
	u8 a3[MORSE_CMD_MAC_ADDR_LEN];
	u8 a4[MORSE_CMD_MAC_ADDR_LEN];
} __packed;

/**
 * struct morse_cmd_resp_pv1_store_hc - response message for PV1_STORE_HC
 */
struct morse_cmd_resp_pv1_store_hc {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_pv1_rx_ampdu_config - request message for PV1_RX_AMPDU_CONFIG
 * @addr: Address of peer STA
 * @tid: TID for which BA session is established
 * @ba_session_enable: Flag to notify session establishment/terminate
 * @buf_size: Buffer size of Aggregation
 */
struct morse_cmd_req_pv1_rx_ampdu_config {
	struct morse_cmd_header hdr;
	u8 addr[MORSE_CMD_MAC_ADDR_LEN];
	u8 tid;
	u8 ba_session_enable;
	__le16 buf_size;
} __packed;

/**
 * struct morse_cmd_req_page_slicing_config - request message for PAGE_SLICING_CONFIG
 * @enable: Page slicing enabled or disabled
 */
struct morse_cmd_req_page_slicing_config {
	struct morse_cmd_header hdr;
	u8 enable;
} __packed;

#define MORSE_CMD_HW_SCAN_FLAGS_START		BIT(0)
#define MORSE_CMD_HW_SCAN_FLAGS_ABORT		BIT(1)
#define MORSE_CMD_HW_SCAN_FLAGS_SURVEY		BIT(2)
#define MORSE_CMD_HW_SCAN_FLAGS_STORE		BIT(3)
#define MORSE_CMD_HW_SCAN_FLAGS_1MHZ_PROBES	BIT(4)
#define MORSE_CMD_HW_SCAN_FLAGS_SCHED_START	BIT(5)
#define MORSE_CMD_HW_SCAN_FLAGS_SCHED_STOP	BIT(6)

/**
 * enum morse_cmd_hw_scan_tlv_tag - Tags for the hw scan tlv header
 */
enum morse_cmd_hw_scan_tlv_tag {
	MORSE_CMD_HW_SCAN_TLV_TAG_PAD		= 0,
	MORSE_CMD_HW_SCAN_TLV_TAG_PROBE_REQ	= 1,
	MORSE_CMD_HW_SCAN_TLV_TAG_CHAN_LIST	= 2,
	MORSE_CMD_HW_SCAN_TLV_TAG_POWER_LIST	= 3,
	MORSE_CMD_HW_SCAN_TLV_TAG_DWELL_ON_HOME = 4,
	MORSE_CMD_HW_SCAN_TLV_TAG_SCHED		= 5,
	MORSE_CMD_HW_SCAN_TLV_TAG_FILTER	= 6,
	MORSE_CMD_HW_SCAN_TLV_TAG_SCHED_PARAMS	= 7,
};

/**
 * HW scan TLV
 * @tag: HW scan TLV tag @ref enum morse_cmd_hw_scan_tlv_tag
 * @len: HW scan TLV len
 * @value: HW scan TLV data
 */
struct morse_cmd_hw_scan_tlv {
	__le16 tag;
	__le16 len;
	u8 value[];
} __packed;

/**
 * struct morse_cmd_req_hw_scan - request message for HW_SCAN
 * @flags: Flags to configure the scan request
 * @dwell_time_ms: The total dwell time on each channel (in ms)
 * @variable: Contains channel list, tx power, and probe req template. Information stored as tlvs
 *            @ref struct morse_cmd_hw_scan_tlv
 *
 * @brief Request to start scanning in softmac (e.g. Linux-hosted) mode from within the
 * firmware. This command differs to the above in that the upper mac (MLME) provides the
 * channel list and filled probe request template as part of this data structure.
 *
 * The LMAC (in reality the host core) is responsible for managing
 * channel switching, probe request scheduling, returning to the home
 * channel after scan completion.
 *
 * Length is varaible and can be acessed in the hdr.length
 */
struct morse_cmd_req_hw_scan {
	struct morse_cmd_header hdr;
	__le32 flags;
	__le32 dwell_time_ms;
	u8 variable[];
} __packed;

#define MORSE_CMD_WHITELIST_FLAGS_CLEAR BIT(0)

/**
 * struct morse_cmd_req_set_whitelist - request message for SET_WHITELIST
 * @flags: Flags
 * @ip_protocol: IP protocol
 * @llc_protocol: Link layer protocol
 * @src_ip: Source IP address
 * @dest_ip: Destination IP address
 * @netmask: Netmask
 * @src_port: TCP or UDP source port
 * @dest_port: TCP or UDP destination port
 *
 * @brief Configure whitelist filtering
 */
struct morse_cmd_req_set_whitelist {
	struct morse_cmd_header hdr;
	u8 flags;
	u8 ip_protocol;
	__be16 llc_protocol;
	__be32 src_ip;
	__be32 dest_ip;
	__be32 netmask;
	__be16 src_port;
	__be16 dest_port;
} __packed;

/**
 * Params for arp periodic request
 */
struct morse_cmd_arp_periodic_params {
	__le32 refresh_period_s;
	__le32 destination_ip;
	u8 send_as_garp;
} __packed;

/**
 * struct morse_cmd_req_arp_periodic_refresh - request message for ARP_PERIODIC_REFRESH
 */
struct morse_cmd_req_arp_periodic_refresh {
	struct morse_cmd_header hdr;
	struct morse_cmd_arp_periodic_params config;
} __packed;

#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_PERIOD		BIT(0)
#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_RETRY_COUNT	BIT(1)
#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_RETRY_INTERVAL	BIT(2)
#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_SRC_IP_ADDR	BIT(3)
#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_DEST_IP_ADDR	BIT(4)
#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_SRC_PORT	BIT(5)
#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_DEST_PORT	BIT(6)

/**
 * struct morse_cmd_req_set_tcp_keepalive - request message for SET_TCP_KEEPALIVE
 */
struct morse_cmd_req_set_tcp_keepalive {
	struct morse_cmd_header hdr;
	u8 enabled;
	u8 retry_count;
	u8 retry_interval_s;
	u8 set_cfgs;
	__be32 src_ip;
	__be32 dest_ip;
	__be16 src_port;
	__be16 dest_port;
	__le16 period_s;
} __packed;

/**
 * enum morse_cmd_power_mode - Modes for the FORCE_POWER_MODE command
 */
enum morse_cmd_power_mode {
	MORSE_CMD_POWER_MODE_SNOOZE	= 0,
	MORSE_CMD_POWER_MODE_DEEP_SLEEP = 1,
	MORSE_CMD_POWER_MODE_HIBERNATE	= 2,
};

/**
 * struct morse_cmd_req_force_power_mode - request message for FORCE_POWER_MODE
 * @mode: Mode of operation to force, see @ref enum morse_cmd_power_mode
 */
struct morse_cmd_req_force_power_mode {
	struct morse_cmd_header hdr;
	__le32 mode;
} __packed;

/**
 * struct morse_cmd_req_li_sleep - request message for LI_SLEEP
 * @listen_interval: Listen interval value if enabled
 */
struct morse_cmd_req_li_sleep {
	struct morse_cmd_header hdr;
	__le32 listen_interval;
} __packed;

/**
 * Details for a disabled channel
 * @freq_100khz: Frequency (100 kHz units for compression)
 * @bw_mhz: Bandwidth (MHz)
 */
struct morse_cmd_disabled_channel_entry {
	__le16 freq_100khz;
	u8 bw_mhz;
} __packed;

/**
 * struct morse_cmd_resp_get_disabled_channels - response message for GET_DISABLED_CHANNELS
 *
 * Disabled channels as per the firmware BCF
 */
struct morse_cmd_resp_get_disabled_channels {
	struct morse_cmd_header hdr;
	__le32 status;
	__le32 n_channels;
	struct morse_cmd_disabled_channel_entry channels[];
} __packed;

/**
 * struct morse_cmd_req_set_cqm_rssi - request message for SET_CQM_RSSI
 * @threshold: RSSI threshold (dBm) at which signal change is detected and event is sent.
 * @hysteresis: RSSI hysteresis (dBm), the minimum amount of RSSI change required to sent event.
 *
 * Set the Connection Quality Monitor (CQM) parameters to detect the signal change
 */
struct morse_cmd_req_set_cqm_rssi {
	struct morse_cmd_header hdr;
	__sle32 threshold;
	__le32 hysteresis;
} __packed;

/**
 * struct morse_cmd_req_get_apf_capabilities - request message for GET_APF_CAPABILITIES
 */
struct morse_cmd_req_get_apf_capabilities {
	struct morse_cmd_header hdr;
} __packed;

/**
 * struct morse_cmd_resp_get_apf_capabilities - response message for GET_APF_CAPABILITIES
 * @max_length: Maximum length of the memory allocated for APF program and data
 * @version: APF version supported by the chip
 *
 * Get APF capabilities from chip
 */
struct morse_cmd_resp_get_apf_capabilities {
	struct morse_cmd_header hdr;
	__le32 status;
	__le32 max_length;
	u8 version;
} __packed;

/**
 * struct morse_cmd_req_read_write_apf - request message for READ_WRITE_APF
 * @offset: Offset in bytes within APF memory and valid only for read operations
 * @program_length: Length of the filter in bytes and valid only for write operations
 * @write: Indicates whether to read or write into packet filtering memory. Value of 1 indicates
 *         write operation to update filter bytecode, Value of 0 indicates read operation to read
 *         memory allocated for packet filtering.
 * @program: Points to filter bytecode when write is set 1
 *
 * Read or write into APF memory
 */
struct morse_cmd_req_read_write_apf {
	struct morse_cmd_header hdr;
	__le32 offset;
	__le16 program_length;
	u8 write;
	u8 program[];
} __packed;

/**
 * struct morse_cmd_resp_read_write_apf - response message for READ_WRITE_APF
 * @program_length: Length of the buffer in bytes pointed by program and valid only for read
 *                  operations.
 * @program: Points to APF data and valid only for read operations
 */
struct morse_cmd_resp_read_write_apf {
	struct morse_cmd_header hdr;
	__le32 status;
	__le16 program_length;
	u8 program[];
} __packed;

/**
 * struct morse_cmd_req_set_sta_type - request message for SET_STA_TYPE
 */
struct morse_cmd_req_set_sta_type {
	struct morse_cmd_header hdr;
	u8 sta_type;
} __packed;

/**
 * struct morse_cmd_req_set_enc_mode - request message for SET_ENC_MODE
 */
struct morse_cmd_req_set_enc_mode {
	struct morse_cmd_header hdr;
	u8 enc_mode;
} __packed;

/**
 * struct morse_cmd_req_test_ba - request message for TEST_BA
 */
struct morse_cmd_req_test_ba {
	struct morse_cmd_header hdr;
	u8 addr[MORSE_CMD_MAC_ADDR_LEN];
	u8 start;
	u8 tx;
	__le32 tid;
} __packed;

/**
 * struct morse_cmd_req_set_listen_interval - request message for SET_LISTEN_INTERVAL
 */
struct morse_cmd_req_set_listen_interval {
	struct morse_cmd_header hdr;
	__le16 listen_interval;
} __packed;

/**
 * struct morse_cmd_req_set_ampdu - request message for SET_AMPDU
 */
struct morse_cmd_req_set_ampdu {
	struct morse_cmd_header hdr;
	u8 ampdu_enabled;
} __packed;

/**
 * struct morse_cmd_req_set_s1g_op_class - request message for SET_S1G_OP_CLASS
 */
struct morse_cmd_req_set_s1g_op_class {
	struct morse_cmd_header hdr;
	u8 opclass;
	u8 prim_opclass;
} __packed;

/**
 * struct morse_cmd_req_send_wake_action_frame - request message for SEND_WAKE_ACTION_FRAME
 */
struct morse_cmd_req_send_wake_action_frame {
	struct morse_cmd_header hdr;
	u8 dest_addr[MORSE_CMD_MAC_ADDR_LEN];
	__le32 payload_size;
	u8 payload[];
} __packed;

#define MORSE_CMD_MAX_VENDOR_IE_LENGTH 255
/** VENDOR_IE_CONFIG management flags */
#define MORSE_CMD_VENDOR_IE_TYPE_FLAG_BEACON		BIT(0)
#define MORSE_CMD_VENDOR_IE_TYPE_FLAG_PROBE_REQ		BIT(1)
#define MORSE_CMD_VENDOR_IE_TYPE_FLAG_PROBE_RESP	BIT(2)
#define MORSE_CMD_VENDOR_IE_TYPE_FLAG_ASSOC_REQ		BIT(3)
#define MORSE_CMD_VENDOR_IE_TYPE_FLAG_ASSOC_RESP	BIT(4)

/**
 * enum morse_cmd_vendor_ie_op - Set vendor information operation codes
 */
enum morse_cmd_vendor_ie_op {
	MORSE_CMD_VENDOR_IE_OP_ADD_ELEMENT	= 0,
	MORSE_CMD_VENDOR_IE_OP_CLEAR_ELEMENTS	= 1,
	MORSE_CMD_VENDOR_IE_OP_ADD_FILTER	= 2,
	MORSE_CMD_VENDOR_IE_OP_CLEAR_FILTERS	= 3,
	MORSE_CMD_VENDOR_IE_OP_INVALID		= U16_MAX,
};

/**
 * struct morse_cmd_req_vendor_ie_config - request message for VENDOR_IE_CONFIG
 */
struct morse_cmd_req_vendor_ie_config {
	struct morse_cmd_header hdr;
	__le16 opcode;
	__le16 mgmt_type_mask;
	u8 data[MORSE_CMD_MAX_VENDOR_IE_LENGTH];
} __packed;

/**
 * struct morse_cmd_resp_vendor_ie_config - response message for VENDOR_IE_CONFIG
 */
struct morse_cmd_resp_vendor_ie_config {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * enum morse_cmd_twt_conf_op - Operation codes for the tet config command
 */
enum morse_cmd_twt_conf_op {
	MORSE_CMD_TWT_CONF_OP_CONFIGURE			= 0,
	MORSE_CMD_TWT_CONF_OP_FORCE_INSTALL_AGREEMENT	= 1,
	MORSE_CMD_TWT_CONF_OP_REMOVE_AGREEMENT		= 2,
	MORSE_CMD_TWT_CONF_OP_CONFIGURE_EXPLICIT	= 3,
};

/**
 * Explicit declaration of the TWT wake interval as expected from WFA
 */
struct morse_cmd_explicit_twt_wake_interval {
	__le16 wake_interval_mantissa;
	u8 wake_interval_exponent;
	u8 __padding[5];
} __packed;

/**
 * Union of the twt wake interval
 */
union morse_cmd_wake_interval {
	__le64 wake_interval_us;
	struct morse_cmd_explicit_twt_wake_interval explicit_twt;
} __packed;

/**
 * struct morse_cmd_req_set_twt_conf - request message for SET_TWT_CONF
 * @opcode: TWT subcommands, see @ref morse_cmd_twt_conf_op
 * @flow_id: The flow (twt) identifier for the agreement to set, install or remove
 * @target_wake_time: The target wake time (TSF) for the first TWT service period
 * @wake_interval: Wake interval described explicitly or in usecs
 * @wake_duration_us: Minimum wake duration during TWT service period (usecs)
 * @twt_setup_command: TWT setup command to use (0: request, 1: suggest, 2: demand)
 */
struct morse_cmd_req_set_twt_conf {
	struct morse_cmd_header hdr;
	u8 opcode;
	u8 flow_id;
	__le64 target_wake_time;
	union morse_cmd_wake_interval wake_interval;
	__le32 wake_duration_us;
	u8 twt_setup_command;
	u8 __padding[3];
} __packed;

#define MORSE_CMD_MAX_AVAILABLE_CHANNELS 255

/**
 * Channel information for get available channels. Structure should not vary from that of struct
 * morse_channel in dot11ah.h in the driver as channel information is derived from this definition.
 */
struct morse_cmd_channel_info {
	__le32 frequency_khz;
	u8 channel_5g;
	u8 channel_s1g;
	u8 bandwidth_mhz;
} __packed;

/**
 * struct morse_cmd_resp_get_available_channels - response message for GET_AVAILABLE_CHANNELS
 */
struct morse_cmd_resp_get_available_channels {
	struct morse_cmd_header hdr;
	__le32 status;
	__le32 num_channels;
	struct morse_cmd_channel_info channels[MORSE_CMD_MAX_AVAILABLE_CHANNELS];
} __packed;

#define MORSE_CMD_S1G_CAP0_S1G_LONG	BIT(0)
#define MORSE_CMD_S1G_CAP0_SGI_1MHZ	BIT(1)
#define MORSE_CMD_S1G_CAP0_SGI_2MHZ	BIT(2)
#define MORSE_CMD_S1G_CAP0_SGI_4MHZ	BIT(3)
#define MORSE_CMD_S1G_CAP0_SGI_8MHZ	BIT(4)
#define MORSE_CMD_S1G_CAP0_SGI_16MHZ	BIT(5)

/**
 * struct morse_cmd_req_set_ecsa_s1g_info - request message for SET_ECSA_S1G_INFO
 * @operating_channel_freq_hz: Operating Channel Frequency Hz. Endianness __le32 op_chan_freq_hz is
 *                             not considered as the cmd is indicated to driver and not chip.
 * @opclass: Global operating class
 * @primary_channel_bw_mhz: Primary channel bw in MHz
 * @prim_1mhz_ch_idx: 1MHz channel index
 * @operating_channel_bw_mhz: Operating channel bandwidth in MHz
 * @prim_opclass: Global operating class for primary chan
 */
struct morse_cmd_req_set_ecsa_s1g_info {
	struct morse_cmd_header hdr;
	__le32 operating_channel_freq_hz;
	u8 opclass;
	u8 primary_channel_bw_mhz;
	u8 prim_1mhz_ch_idx;
	u8 operating_channel_bw_mhz;
	u8 prim_opclass;
	u8 s1g_cap0;
	u8 s1g_cap1;
	u8 s1g_cap2;
	u8 s1g_cap3;
} __packed;

/**
 * struct morse_cmd_resp_get_hw_version - response message for GET_HW_VERSION
 */
struct morse_cmd_resp_get_hw_version {
	struct morse_cmd_header hdr;
	__le32 status;
	u8 hw_version[64];
} __packed;

#define MORSE_CMD_CAC_CFG_CHANGE_RULE_MAX	8
#define MORSE_CMD_CAC_CFG_ARFS_MAX		99
#define MORSE_CMD_CAC_CFG_CHANGE_MAX		99
#define MORSE_CMD_CAC_CFG_CHANGE_STEP		5

/**
 * enum morse_cmd_cac_op - CAC command operation codes
 */
enum morse_cmd_cac_op {
	MORSE_CMD_CAC_OP_DISABLE	= 0,
	MORSE_CMD_CAC_OP_ENABLE		= 1,
	MORSE_CMD_CAC_OP_CFG_GET	= 2,
	MORSE_CMD_CAC_OP_CFG_SET	= 3,
};

/**
 * CAC threshold change rule
 * @arfs: Threshold in Authentication Request Frames per Second
 * @threshold_change: Percentage change to apply to threshold if condition is matched
 */
struct morse_cmd_cac_change_rule {
	__le16 arfs;
	__sle16 threshold_change;
} __packed;

/**
 * struct morse_cmd_req_cac - request message for CAC
 * @opcode: CAC subcommand @ref morse_cmd_cac_op
 * @rule_tot: Number of threshold change rules
 * @rule: Threshold change rule (%)
 */
struct morse_cmd_req_cac {
	struct morse_cmd_header hdr;
	u8 opcode;
	u8 rule_tot;
	struct morse_cmd_cac_change_rule rule[MORSE_CMD_CAC_CFG_CHANGE_RULE_MAX];
} __packed;

/**
 * struct morse_cmd_resp_cac - response message for CAC
 * @rule_tot: Number of threshold change rules
 * @rule: Threshold change rule (%)
 */
struct morse_cmd_resp_cac {
	struct morse_cmd_header hdr;
	__le32 status;
	u8 rule_tot;
	struct morse_cmd_cac_change_rule rule[MORSE_CMD_CAC_CFG_CHANGE_RULE_MAX];
} __packed;

/**
 * Command request structure for OCS commands to the driver
 */
struct morse_cmd_ocs_driver_req {
	__le32 op_channel_freq_hz;
	u8 op_channel_bw_mhz;
	u8 pri_channel_bw_mhz;
	u8 pri_1mhz_channel_index;
} __packed;

/**
 * Command response structure for OCS commands to the driver
 */
struct morse_cmd_ocs_driver_resp {
	u8 running;
} __packed;

/**
 * struct morse_cmd_req_ocs_driver - request message for OCS_DRIVER
 * @subcmd: Subcommand value @ref morse_cmd_ocs_subcmd
 */
struct morse_cmd_req_ocs_driver {
	struct morse_cmd_header hdr;
	__le32 subcmd;
	union {
		u8 opaque[0];
		struct morse_cmd_ocs_driver_req config;
	};
} __packed;

/**
 * struct morse_cmd_resp_ocs_driver - response message for OCS_DRIVER
 * @subcmd: Subcommand value @ref morse_cmd_ocs_subcmd
 *
 * @note driver response should not differ from the firmware response @ref struct morse_cmd_resp_ocs
 */
struct morse_cmd_resp_ocs_driver {
	struct morse_cmd_header hdr;
	__le32 status;
	__le32 subcmd;
	union {
		u8 opaque[0];
		struct morse_cmd_ocs_driver_resp ocs_status;
	};
} __packed;

#define MORSE_CMD_IFNAMSIZ 16

/**
 * struct morse_cmd_req_mbssid - request message for MBSSID
 * @max_bssid_indicator: Maximum supported BSS to be updated in MBSSID IE
 * @transmitter_iface: Beacon or probe reponse transmitting interface name
 */
struct morse_cmd_req_mbssid {
	struct morse_cmd_header hdr;
	u8 max_bssid_indicator;
	s8 transmitter_iface[MORSE_CMD_IFNAMSIZ];
} __packed;

#define MORSE_CMD_MESH_ID_LEN_MAX		32
#define MORSE_CMD_MESH_BEACONLESS_MODE_DISABLE	0
#define MORSE_CMD_MESH_BEACONLESS_MODE_ENABLE	1
#define MORSE_CMD_MESH_PEER_LINKS_MIN		0
#define MORSE_CMD_MESH_PEER_LINKS_MAX		10

/**
 * struct morse_cmd_req_set_mesh_config - request message for SET_MESH_CONFIG
 * @mesh_id_len: Mesh ID Len
 * @mesh_id: Mesh ID, equivalent to SSID in infra
 * @mesh_beaconless_mode: Mesh beaconless mode enabled/disabled
 * @max_plinks: Maximum number of peer links
 *
 * Structure derived from struct morse_mesh_config in morse.h in the driver
 */
struct morse_cmd_req_set_mesh_config {
	struct morse_cmd_header hdr;
	u8 mesh_id_len;
	u8 mesh_id[MORSE_CMD_MESH_ID_LEN_MAX];
	u8 mesh_beaconless_mode;
	u8 max_plinks;
} __packed;

/**
 * struct morse_cmd_req_set_mcba_conf - request message for SET_MCBA_CONF
 * @mbca_config: Configuration to enable or disable MBCA TBTT Selection and Adjustment
 * @beacon_timing_report_interval: Beacon Timing Element Report interval
 * @min_beacon_gap_ms: Minimum gap between our beacon and neighbor beacons
 * @mbss_start_scan_duration_ms: Initial scan duration to find neighbor mesh peers in the MBSS
 * @tbtt_adj_interval_ms: TBTT adjustment timer interval in LMAC firmware
 */
struct morse_cmd_req_set_mcba_conf {
	struct morse_cmd_header hdr;
	u8 mbca_config;
	u8 beacon_timing_report_interval;
	u8 min_beacon_gap_ms;
	__le16 mbss_start_scan_duration_ms;
	__le16 tbtt_adj_interval_ms;
} __packed;

/**
 * struct morse_cmd_req_dynamic_peering_config - request message for DYNAMIC_PEERING_CONFIG
 * @enabled: Enable or disable mesh dynamic peering
 * @rssi_margin: RSSI margin to consider while selecting a peer to kick out
 * @blacklist_timeout: Kicked out peer is not allowed connection during this period
 */
struct morse_cmd_req_dynamic_peering_config {
	struct morse_cmd_header hdr;
	u8 enabled;
	u8 rssi_margin;
	__le32 blacklist_timeout;
} __packed;

#define MORSE_CMD_CFG_RAW_FLAG_ENABLE	BIT(0)
#define MORSE_CMD_CFG_RAW_FLAG_DELETE	BIT(1)
#define MORSE_CMD_CFG_RAW_FLAG_UPDATE	BIT(2)
#define MORSE_CMD_CFG_RAW_FLAG_DYNAMIC	BIT(3)

/**
 * enum morse_cmd_raw_tlv_tag - Tags for the RAW TLV
 */
enum morse_cmd_raw_tlv_tag {
	MORSE_CMD_RAW_TLV_TAG_SLOT_DEF		= 0,
	MORSE_CMD_RAW_TLV_TAG_GROUP		= 1,
	MORSE_CMD_RAW_TLV_TAG_START_TIME	= 2,
	MORSE_CMD_RAW_TLV_TAG_PRAW		= 3,
	MORSE_CMD_RAW_TLV_TAG_BCN_SPREAD	= 4,
	MORSE_CMD_RAW_TLV_TAG_DYN_GLOBAL	= 5,
	MORSE_CMD_RAW_TLV_TAG_DYN_CONFIG	= 6,
	MORSE_CMD_RAW_TLV_TAG_LAST		= 7,
};

/**
 * Slot definition is required for new raw configs
 * @raw_duration_us: Total length of the RAW window. @ref raw_duration_us / num_slots =
 *                   slot_duration
 * @num_slots: Number of individual "slots" within the RAW window
 */
struct morse_cmd_raw_tlv_slot_def {
	u8 tag;
	__le32 raw_duration_us;
	u8 num_slots;
	u8 cross_slot_bleed;
} __packed;

/**
 * RAW group information
 * @aid_start: Start AID for this raw config
 * @aid_end: End AID for this config (inclusive)
 */
struct morse_cmd_raw_tlv_group {
	u8 tag;
	__le16 aid_start;
	__le16 aid_end;
} __packed;

/**
 * RAW start time information
 * @start_time_us: Time the RAW window starts, measured from the end of the frame carrying RPS IE
 */
struct morse_cmd_raw_tlv_start_time {
	u8 tag;
	__le32 start_time_us;
} __packed;

/**
 * Periodic RAW information
 */
struct morse_cmd_raw_tlv_praw {
	u8 tag;
	u8 periodicity;
	u8 validity;
	u8 start_offset;
	u8 refresh_on_expiry;
} __packed;

/**
 * RAW beacon spreading information
 */
struct morse_cmd_raw_tlv_bcn_spread {
	u8 tag;
	__le16 max_spread;
	__le16 nominal_sta_per_bcn;
} __packed;

/**
 * Global configuration for dynamic RAW configuration
 * @num_configs: Number of dynamic RAW confgis present
 * @num_bcn_indexes: The maximum number of beacon frames to add RAW configs to
 */
struct morse_cmd_raw_tlv_dyn_global {
	u8 tag;
	__le16 num_configs;
	__le16 num_bcn_indexes;
} __packed;

/**
 * Single dynamic RAW config entry in the batch of RAW configs
 * @id: Unique config id of dynamic RAW config entry
 * @index: Index of beacon to include this RAW config into
 * @len: Length of RAW config
 * @variable: RAW TLV data
 */
struct morse_cmd_raw_tlv_dyn_config {
	u8 tag;
	__le16 id;
	__le16 index;
	__le16 len;
	u8 variable[];
} __packed;

/**
 * RAW TLV data
 */
union morse_cmd_raw_tlvs {
	u8 tag;
	struct morse_cmd_raw_tlv_slot_def slot_def;
	struct morse_cmd_raw_tlv_group group;
	struct morse_cmd_raw_tlv_start_time start_time;
	struct morse_cmd_raw_tlv_praw praw;
	struct morse_cmd_raw_tlv_bcn_spread bcn_spread;
	struct morse_cmd_raw_tlv_dyn_global dyn_global;
	struct morse_cmd_raw_tlv_dyn_config dyn_config;
} __packed;

/**
 * struct morse_cmd_req_config_raw - request message for CONFIG_RAW
 * @flags: Flags for this RAW config
 * @id: ID to reference this RAW config. If ID already exists, existing config will be overwritten.
 *      ID of 0 is reserved to indicate operate on RAW globally.
 * @variable: RAW TLV data
 */
struct morse_cmd_req_config_raw {
	struct morse_cmd_header hdr;
	__le32 flags;
	__le16 id;
	u8 variable[];
} __packed;

/**
 * struct morse_cmd_req_config_bss_stats - request message for CONFIG_BSS_STATS
 * @enable: Flag to enable or disable the module
 * @monitor_window_ms: BSS statistics reporting interval in msec
 */
struct morse_cmd_req_config_bss_stats {
	struct morse_cmd_header hdr;
	u8 enable;
	__le32 monitor_window_ms;
} __packed;

/** Maximum length of extra IEs passed to scan request */
#define MORSE_CMD_SCAN_EXTRA_IES_MAX_LEN 1022

/**
 * struct morse_cmd_req_start_scan - request message for START_SCAN
 * @dwell_time_ms: Time to dwell on each channel waiting for probe responses/beacons
 * @n_ssids: Number of SSIDs to scan for.  Currently this must be either 0 or 1. In future this
 *           command could be expanded to allow multiple SSIDs.  If this field is 0, the @ref ssid
 *           and @ref ssid_len fields are ignored and a passive scan will be started (no probe
 *           requests). If this field is 1, @ref ssid_len may still be zero (active scan with probe
 *           requests for the wildcard SSID).
 * @ssid_len: Length of @ref ssid
 * @ssid: SSID to scan for
 * @extra_ies_len: Length of @ref extra_ies
 * @extra_ies: Extra Information Elements to include in probe requests
 *
 * Request a scan (fullmac only)
 */
struct morse_cmd_req_start_scan {
	struct morse_cmd_header hdr;
	__le32 dwell_time_ms;
	u8 n_ssids;
	u8 __padding[2];
	u8 ssid_len;
	u8 ssid[MORSE_CMD_SSID_MAX_LEN];
	__le16 extra_ies_len;
	u8 extra_ies[];
} __packed;

/**
 * struct morse_cmd_req_abort_scan - request message for ABORT_SCAN
 */
struct morse_cmd_req_abort_scan {
	struct morse_cmd_header hdr;
} __packed;

/** Maximum length of SAE password */
#define MORSE_CMD_SAE_PASSWORD_MAX_LEN 92
/** Maximum length of extra association IEs */
#define MORSE_CMD_EXTRA_ASSOC_IES_MAX_LEN 1022
/** Roam to another BSS within the ESS (reassociate without disconnecting) */
#define MORSE_CMD_CONNECT_FLAG_ROAM BIT(0)

/**
 * enum morse_cmd_connect_auth_type - Authentication type for fullmac connections
 */
enum morse_cmd_connect_auth_type {
	MORSE_CMD_CONNECT_AUTH_TYPE_INVALID	= 0,
	MORSE_CMD_CONNECT_AUTH_TYPE_OPEN	= 1,
	MORSE_CMD_CONNECT_AUTH_TYPE_OWE		= 2,
	MORSE_CMD_CONNECT_AUTH_TYPE_SAE		= 3,
	MORSE_CMD_CONNECT_AUTH_TYPE_AUTOMATIC	= U8_MAX,
};

/**
 * enum morse_cmd_connect_tlv_tag - Tags for the fullmac CONNECT request TLVs
 * @MORSE_CMD_CONNECT_TLV_TAG_AUTH_TYPE: Authentication type to use when connecting, see @ref{enum
 *                                       morse_cmd_connect_auth_type}
 * @MORSE_CMD_CONNECT_TLV_TAG_SSID: SSID to connect to
 * @MORSE_CMD_CONNECT_TLV_TAG_SAE_PWD: Password to use for authentication (if @ref auth_type is SAE)
 * @MORSE_CMD_CONNECT_TLV_TAG_EXTRA_ASSOC_IES: Association Request IEs from host supplicant
 * @MORSE_CMD_CONNECT_TLV_TAG_BSSID: Connect only to a specific BSS, instead of any BSS with
 *                                   matching SSID
 * @MORSE_CMD_CONNECT_TLV_TAG_BG_SCAN_PERIOD: Background scan period in seconds
 * @MORSE_CMD_CONNECT_TLV_TAG_4ADDR_MODE: Whether to act as a Linux "4-address mode" station
 */
enum morse_cmd_connect_tlv_tag {
	MORSE_CMD_CONNECT_TLV_TAG_PAD			= 0,
	MORSE_CMD_CONNECT_TLV_TAG_AUTH_TYPE		= 1,
	MORSE_CMD_CONNECT_TLV_TAG_SSID			= 2,
	MORSE_CMD_CONNECT_TLV_TAG_SAE_PWD		= 3,
	MORSE_CMD_CONNECT_TLV_TAG_EXTRA_ASSOC_IES	= 4,
	MORSE_CMD_CONNECT_TLV_TAG_BSSID			= 5,
	MORSE_CMD_CONNECT_TLV_TAG_BG_SCAN_PERIOD	= 6,
	MORSE_CMD_CONNECT_TLV_TAG_4ADDR_MODE		= 7,
};

/**
 * Fullmac CONNECT request TLV
 * @tag: Fullmac CONNECT request TLV tag, see @ref{enum morse_cmd_connect_tlv_tag}
 * @len: Fullmac CONNECT request TLV length
 * @value: Fullmac CONNECT request TLV value
 */
struct morse_cmd_connect_tlv {
	__le16 tag;
	__le16 len;
	u8 value[];
} __packed;

/**
 * struct morse_cmd_req_connect - request message for CONNECT
 * @flags: Flags to configure the connection request (see @c MORSE_CMD_CONNECT_FLAG_*)
 * @unused: Reserved for future usage, must be zero
 * @variable: Connection parameters, represented as TLVs (see @ref{struct morse_cmd_connect_tlv})
 *
 * Request connection (fullmac only)
 */
struct morse_cmd_req_connect {
	struct morse_cmd_header hdr;
	__le32 flags;
	u8 unused[4];
	u8 variable[];
} __packed;

/**
 * struct morse_cmd_req_disconnect - request message for DISCONNECT
 *
 * Disconnect (fullmac only)
 */
struct morse_cmd_req_disconnect {
	struct morse_cmd_header hdr;
} __packed;

/**
 * struct morse_cmd_req_get_connection_state - request message for GET_CONNECTION_STATE
 *
 * Get the connection state (fullmac only)
 */
struct morse_cmd_req_get_connection_state {
	struct morse_cmd_header hdr;
} __packed;

/**
 * struct morse_cmd_resp_get_connection_state - response message for GET_CONNECTION_STATE
 * @beacon_interval_tu: Beacon interval in TUs
 * @dtim_period: DTIM period
 * @rssi: Signal strength of the most recently received beacon in dBm
 * @connected_time_s: Time since connection was established in seconds
 *
 * Connection state response (fullmac only)
 */
struct morse_cmd_resp_get_connection_state {
	struct morse_cmd_header hdr;
	__le32 status;
	__le16 beacon_interval_tu;
	__le16 dtim_period;
	__sle16 rssi;
	u8 __padding[2];
	__le32 connected_time_s;
} __packed;

/**
 * enum morse_cmd_mcs10_mode
 */
enum morse_cmd_mcs10_mode {
	MORSE_CMD_MCS10_MODE_DISABLED	= 0,
	MORSE_CMD_MCS10_MODE_FORCED	= 1,
	MORSE_CMD_MCS10_MODE_AUTO	= 2,
};

/**
 * struct morse_cmd_req_set_rate_control - request message for SET_RATE_CONTROL
 * @mcs_mask: TX/RX MCS mask
 * @mcs10_mode: MCS 10 configuration
 * @enable_sgi_rc: Allow/disallow rate control to use SGI
 */
struct morse_cmd_req_set_rate_control {
	struct morse_cmd_header hdr;
	__le16 mcs_mask;
	u8 mcs10_mode;
	u8 enable_sgi_rc;
} __packed;

/**
 * struct morse_cmd_req_get_rssi - request message for GET_RSSI
 */
struct morse_cmd_req_get_rssi {
	struct morse_cmd_header hdr;
} __packed;

/**
 * struct morse_cmd_resp_get_rssi - response message for GET_RSSI
 */
struct morse_cmd_resp_get_rssi {
	struct morse_cmd_header hdr;
	__le32 status;
	__sle32 rssi0;
	__sle32 rssi1;
	__sle32 rssi2;
	__sle32 rssi3;
	__sle32 rssi4;
	__sle32 rssi5;
	__sle32 rssi6;
	__sle32 rssi7;
} __packed;

#define MORSE_CMD_SET_IFS_MIN_USECS 160

/**
 * struct morse_cmd_req_set_ifs - request message for SET_IFS
 * @period_usecs: IFS in microseconds
 */
struct morse_cmd_req_set_ifs {
	struct morse_cmd_header hdr;
	__le32 period_usecs;
} __packed;

/**
 * struct morse_cmd_resp_set_ifs - response message for SET_IFS
 */
struct morse_cmd_resp_set_ifs {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_set_fem_settings - request message for SET_FEM_SETTINGS
 * @tx_antenna: @ref enum morse_cmd_fem_antenna
 * @rx_antenna: @ref enum morse_cmd_fem_antenna
 * @lna_enabled: Bool, 1=enabled, 0=disabled
 * @pa_enabled: Bool, 1=enabled, 0=disabled
 */
struct morse_cmd_req_set_fem_settings {
	struct morse_cmd_header hdr;
	__le32 tx_antenna;
	__le32 rx_antenna;
	__le32 lna_enabled;
	__le32 pa_enabled;
} __packed;

/**
 * struct morse_cmd_resp_set_fem_settings - response message for SET_FEM_SETTINGS
 */
struct morse_cmd_resp_set_fem_settings {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_set_txop - request message for SET_TXOP
 */
struct morse_cmd_req_set_txop {
	struct morse_cmd_header hdr;
	u8 min_packet_count;
} __packed;

/**
 * struct morse_cmd_resp_set_txop - response message for SET_TXOP
 */
struct morse_cmd_resp_set_txop {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_set_control_response - request message for SET_CONTROL_RESPONSE
 * @direction: Set to 0 for outbound, 1 for inbound. When setting inbound it is saying the other
 *             STA/AP has set the 'control response 1mhz preamble' bit in their S1G capabilities and
 *             we must adjust our ack timeouts appropriately.
 * @control_response_1mhz_en: Sets the control response mode. 0  : Control frames that are a
 *                            response are sent at the BW of the original packet 1  : Control frames
 *                            that are a response are sent at 1MHz
 */
struct morse_cmd_req_set_control_response {
	struct morse_cmd_header hdr;
	u8 direction;
	u8 control_response_1mhz_en;
} __packed;

/**
 * struct morse_cmd_resp_set_control_response - response message for SET_CONTROL_RESPONSE
 */
struct morse_cmd_resp_set_control_response {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_set_periodic_cal - request message for SET_PERIODIC_CAL
 */
struct morse_cmd_req_set_periodic_cal {
	struct morse_cmd_header hdr;
	__le32 periodic_cal_en_mask;
} __packed;

/**
 * struct morse_cmd_resp_set_periodic_cal - response message for SET_PERIODIC_CAL
 */
struct morse_cmd_resp_set_periodic_cal {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_set_bcn_rssi_threshold - request message for SET_BCN_RSSI_THRESHOLD
 */
struct morse_cmd_req_set_bcn_rssi_threshold {
	struct morse_cmd_header hdr;
	u8 threshold_db;
} __packed;

/**
 * struct morse_cmd_resp_set_bcn_rssi_threshold - response message for SET_BCN_RSSI_THRESHOLD
 */
struct morse_cmd_resp_set_bcn_rssi_threshold {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_set_tx_pkt_lifetime_usecs - request message for SET_TX_PKT_LIFETIME_USECS
 */
struct morse_cmd_req_set_tx_pkt_lifetime_usecs {
	struct morse_cmd_header hdr;
	__le32 lifetime_usecs;
} __packed;

/**
 * struct morse_cmd_resp_set_tx_pkt_lifetime_usecs - response message for SET_TX_PKT_LIFETIME_USECS
 */
struct morse_cmd_resp_set_tx_pkt_lifetime_usecs {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_set_physm_watchdog - request message for SET_PHYSM_WATCHDOG
 */
struct morse_cmd_req_set_physm_watchdog {
	struct morse_cmd_header hdr;
	u8 physm_watchdog_en;
} __packed;

/**
 * struct morse_cmd_req_tx_polar - request message for TX_POLAR
 */
struct morse_cmd_req_tx_polar {
	struct morse_cmd_header hdr;
	u8 enable;
} __packed;

/**
 * struct morse_cmd_evt_sta_state - event message for STA_STATE
 */
struct morse_cmd_evt_sta_state {
	struct morse_cmd_header hdr;
	u8 sta_addr[MORSE_CMD_MAC_ADDR_LEN];
	__le16 aid;
	__le16 state;
} __packed;

/**
 * struct morse_cmd_evt_beacon_loss - event message for BEACON_LOSS
 */
struct morse_cmd_evt_beacon_loss {
	struct morse_cmd_header hdr;
	__le32 num_bcns;
} __packed;

/**
 * struct morse_cmd_evt_sig_field_error - event message for SIG_FIELD_ERROR
 */
struct morse_cmd_evt_sig_field_error {
	struct morse_cmd_header hdr;
	__le64 start_timestamp;
	__le64 end_timestamp;
} __packed;

#define MORSE_CMD_UMAC_TRAFFIC_CONTROL_SOURCE_TWT		BIT(0)
#define MORSE_CMD_UMAC_TRAFFIC_CONTROL_SOURCE_DUTY_CYCLE	BIT(1)

/**
 * struct morse_cmd_evt_umac_traffic_control - event message for UMAC_TRAFFIC_CONTROL
 * @pause_data_traffic: True when traffic from the UMAC should be paused
 * @sources: Bitfield of sources that generated the traffic control event see @ref
 *           morse_cmd_umac_traffic_control_source defines
 */
struct morse_cmd_evt_umac_traffic_control {
	struct morse_cmd_header hdr;
	u8 pause_data_traffic;
	__le32 sources;
} __packed;

/**
 * struct morse_cmd_evt_dhcp_lease_update - event message for DHCP_LEASE_UPDATE
 * @my_ip: My leased IP address or 0 if no lease
 * @netmask: My leased netmask or 0 if no lease
 * @router: My leased router address or 0 if no lease
 * @dns: Upstream DNS server or 0 if no lease
 */
struct morse_cmd_evt_dhcp_lease_update {
	struct morse_cmd_header hdr;
	__le32 my_ip;
	__le32 netmask;
	__le32 router;
	__le32 dns;
} __packed;

/**
 * struct morse_cmd_evt_ocs_done - event message for OCS_DONE
 */
struct morse_cmd_evt_ocs_done {
	struct morse_cmd_header hdr;
	__le64 time_listen;
	__le64 time_rx;
	s8 noise;
	u8 metric;
} __packed;

/**
 * struct morse_cmd_evt_hw_scan_done - event message for HW_SCAN_DONE
 * @aborted: Whether the scan terminated before all channels were scanned
 *
 * Completion event for hw scan
 */
struct morse_cmd_evt_hw_scan_done {
	struct morse_cmd_header hdr;
	u8 aborted;
} __packed;

/**
 * struct morse_cmd_evt_channel_usage - event message for CHANNEL_USAGE
 *
 * Completion event for hw scan
 */
struct morse_cmd_evt_channel_usage {
	struct morse_cmd_header hdr;
	__le64 time_listen;
	__le64 busy_time;
	__le32 freq_hz;
	u8 noise;
	u8 bw_mhz;
} __packed;

/**
 * enum morse_cmd_connection_loss_reason - List of reason codes to use in the
 * `morse_cmd_connection_loss_evt` event
 */
enum morse_cmd_connection_loss_reason {
	MORSE_CMD_CONNECTION_LOSS_REASON_TSF_RESET = 0,
};

/**
 * struct morse_cmd_evt_connection_loss - event message for CONNECTION_LOSS
 * @reason: @ref enum morse_cmd_connection_loss_reason
 */
struct morse_cmd_evt_connection_loss {
	struct morse_cmd_header hdr;
	__le32 reason;
} __packed;

/**
 * struct morse_cmd_evt_sched_scan_results - event message for SCHED_SCAN_RESULTS
 *
 * Notify that results are available from the scheduled scan
 */
struct morse_cmd_evt_sched_scan_results {
	struct morse_cmd_header hdr;
} __packed;

/**
 * enum morse_cmd_cqm_rssi_threshold_event - List of events to use in the
 * `morse_cmd_evt_cqm_rssi_notify` event
 */
enum morse_cmd_cqm_rssi_threshold_event {
	MORSE_CMD_CQM_RSSI_THRESHOLD_EVENT_LOW	= 0,
	MORSE_CMD_CQM_RSSI_THRESHOLD_EVENT_HIGH = 1,
};

/**
 * struct morse_cmd_evt_cqm_rssi_notify - event message for CQM_RSSI_NOTIFY
 * @rssi: Last detected RSSI (dBm)
 * @event: @ref enum morse_cmd_cqm_rssi_threshold_event
 *
 * Notification of RSSI crossing a threshold
 */
struct morse_cmd_evt_cqm_rssi_notify {
	struct morse_cmd_header hdr;
	__sle16 rssi;
	__le16 event;
} __packed;

/**
 * struct morse_cmd_evt_scan_done - event message for SCAN_DONE
 * @aborted: Whether the scan terminated before all channels were scanned
 *
 * Completion event for fullmac scan
 */
struct morse_cmd_evt_scan_done {
	struct morse_cmd_header hdr;
	u8 aborted;
} __packed;

/**
 * enum morse_cmd_scan_result_frame - Frame types of a fullmac scan result event
 */
enum morse_cmd_scan_result_frame {
	MORSE_CMD_SCAN_RESULT_FRAME_UNKNOWN		= 0,
	MORSE_CMD_SCAN_RESULT_FRAME_BEACON		= 1,
	MORSE_CMD_SCAN_RESULT_FRAME_PROBE_RESPONSE	= 2,
};

/**
 * struct morse_cmd_evt_scan_result - event message for SCAN_RESULT
 * @channel_freq_hz: Channel centre frequency in Hz where the frame was received
 * @bw_mhz: Bandwidth in MHz where the frame was received
 * @frame_type: Type of frame. See @ref enum morse_cmd_scan_result_frame_type
 * @rssi: Signal strength of the received frame in dBm
 * @bssid: BSSID of the sending AP
 * @beacon_interval: Value of the Beacon Interval field
 * @capability_info: Value of the Capability Information field
 * @tsf: TSF timestamp in the received frame
 * @ies_len: Length of @ref ies
 * @ies: Information Elements in the received probe response
 *
 * An individual result (probe response or beacon received) during fullmac scan
 */
struct morse_cmd_evt_scan_result {
	struct morse_cmd_header hdr;
	__le32 channel_freq_hz;
	u8 bw_mhz;
	u8 frame_type;
	__sle16 rssi;
	u8 bssid[MORSE_CMD_MAC_ADDR_LEN];
	__le16 beacon_interval;
	__le16 capability_info;
	__le64 tsf;
	__le16 ies_len;
	u8 ies[];
} __packed;

/**
 * struct morse_cmd_evt_connected - event message for CONNECTED
 *
 * Fullmac connection was established
 */
struct morse_cmd_evt_connected {
	struct morse_cmd_header hdr;
	u8 bssid[MORSE_CMD_MAC_ADDR_LEN];
	__sle16 rssi;
	u8 padding_0[8];
	__le16 assoc_resp_ies_len;
	u8 assoc_resp_ies[];
} __packed;

/**
 * struct morse_cmd_evt_beacon_filter_match - event message for BEACON_FILTER_MATCH
 * @ies_len: Length of the IE list in octets.
 * @ies: List of IEs present in the beacon that matched the filter.
 *
 * Beacon found containing a vendor IE with a filtered OUI (fullmac only)
 */
struct morse_cmd_evt_beacon_filter_match {
	struct morse_cmd_header hdr;
	u8 padding_0[4];
	__le32 ies_len;
	u8 ies[];
} __packed;

/**
 * struct morse_cmd_req_set_capabilities - request message for SET_CAPABILITIES
 * @capabilities: MM capabilities
 * @set_caps: Which caps we are setting
 * @morse_mmss_offset: Morse custom MMSS (Minimum MPDU Start Spacing) offset
 *
 * Set the device capabilities manifest
 */
struct morse_cmd_req_set_capabilities {
	struct morse_cmd_header hdr;
	struct morse_cmd_mm_capabilities capabilities;
	u8 set_caps;
	u8 morse_mmss_offset;
} __packed;

/**
 * struct morse_cmd_resp_set_capabilities - response message for SET_CAPABILITIES
 */
struct morse_cmd_resp_set_capabilities {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_set_transmission_rate - request message for SET_TRANSMISSION_RATE
 */
struct morse_cmd_req_set_transmission_rate {
	struct morse_cmd_header hdr;
	__sle32 mcs_index;
	__sle32 bandwidth_mhz;
	__sle32 tx_80211ah_format;
	s8 use_traveling_pilots;
	s8 use_sgi;
	u8 enabled;
	s8 nss_idx;
	s8 use_ldpc;
	s8 use_stbc;
} __packed;

/**
 * struct morse_cmd_resp_set_transmission_rate - response message for SET_TRANSMISSION_RATE
 */
struct morse_cmd_resp_set_transmission_rate {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

#define MORSE_CMD_HOST_BLOCK_TX_FRAMES	BIT(0)
#define MORSE_CMD_HOST_BLOCK_TX_CMD	BIT(1)

/**
 * enum morse_cmd_param_action - Actions to take on the param
 */
enum morse_cmd_param_action {
	MORSE_CMD_PARAM_ACTION_SET	= 0,
	MORSE_CMD_PARAM_ACTION_GET	= 1,
	MORSE_CMD_PARAM_ACTION_LAST	= 2,
};

/**
 * enum morse_cmd_slow_clock_mode - Different slow clock source selection modes
 * @MORSE_CMD_SLOW_CLOCK_MODE_AUTO: Slow clock source would be automatically selected
 * @MORSE_CMD_SLOW_CLOCK_MODE_INTERNAL: Slow clock source would be set to internal
 */
enum morse_cmd_slow_clock_mode {
	MORSE_CMD_SLOW_CLOCK_MODE_AUTO		= 0,
	MORSE_CMD_SLOW_CLOCK_MODE_INTERNAL	= 1,
};

/**
 * enum morse_cmd_param_id - Subcommand IDs for generic get / set command
 */
enum morse_cmd_param_id {
	MORSE_CMD_PARAM_ID_MAX_TRAFFIC_DELIVERY_WAIT_US		= 0,
	MORSE_CMD_PARAM_ID_EXTRA_ACK_TIMEOUT_ADJUST_US		= 1,
	MORSE_CMD_PARAM_ID_TX_STATUS_FLUSH_WATERMARK		= 2,
	MORSE_CMD_PARAM_ID_TX_STATUS_FLUSH_MIN_AMPDU_SIZE	= 3,
	MORSE_CMD_PARAM_ID_POWERSAVE_TYPE			= 4,
	MORSE_CMD_PARAM_ID_SNOOZE_DURATION_ADJUST_US		= 5,
	MORSE_CMD_PARAM_ID_TX_BLOCK				= 6,
	MORSE_CMD_PARAM_ID_FORCED_SNOOZE_PERIOD_US		= 7,
	MORSE_CMD_PARAM_ID_WAKE_ACTION_GPIO			= 8,
	MORSE_CMD_PARAM_ID_WAKE_ACTION_GPIO_PULSE_MS		= 9,
	MORSE_CMD_PARAM_ID_CONNECTION_MONITOR_GPIO		= 10,
	MORSE_CMD_PARAM_ID_INPUT_TRIGGER_GPIO			= 11,
	MORSE_CMD_PARAM_ID_INPUT_TRIGGER_MODE			= 12,
	MORSE_CMD_PARAM_ID_COUNTRY				= 13,
	MORSE_CMD_PARAM_ID_RTS_THRESHOLD			= 14,
	MORSE_CMD_PARAM_ID_HOST_TX_BLOCK			= 15,
	MORSE_CMD_PARAM_ID_MEM_RETENTION_CODE			= 16,
	MORSE_CMD_PARAM_ID_NON_TIM_MODE				= 17,
	MORSE_CMD_PARAM_ID_DYNAMIC_PS_TIMEOUT_MS		= 18,
	MORSE_CMD_PARAM_ID_HOME_CHANNEL_DWELL_MS		= 19,
	MORSE_CMD_PARAM_ID_SLOW_CLOCK_MODE			= 20,
	MORSE_CMD_PARAM_ID_FRAGMENT_THRESHOLD			= 21,
	MORSE_CMD_PARAM_ID_BEACON_LOSS_COUNT			= 22,
	MORSE_CMD_PARAM_ID_LAST					= 23,
};

/**
 * struct morse_cmd_req_get_set_generic_param - request message for GET_SET_GENERIC_PARAM
 * @param_id: The param to perform the action on [enum morse_cmd_param_id]
 * @action: The action to take on the param [get | set]
 * @flags: Any flags to modify the behavior of the action (for forwards/backwards compatibility)
 * @value: The value to set (only applicable for set actions)
 */
struct morse_cmd_req_get_set_generic_param {
	struct morse_cmd_header hdr;
	__le32 param_id;
	__le32 action;
	__le32 flags;
	__le32 value;
} __packed;

/**
 * struct morse_cmd_resp_get_set_generic_param - response message for GET_SET_GENERIC_PARAM
 * @flags: Any flags to signal change of interpretation of response - forwards / backwards
 *         compatibility
 * @value: The value returned (only applicable for get actions)
 */
struct morse_cmd_resp_get_set_generic_param {
	struct morse_cmd_header hdr;
	__le32 status;
	__le32 flags;
	__le32 value;
} __packed;

/**
 * struct morse_cmd_req_turbo_mode - request message for TURBO_MODE
 * @aid: The AID we're enabling/disabling turbo mode for
 * @enabled: Enable/disable turbo mode
 *
 * Request turbo mode for a given STA
 */
struct morse_cmd_req_turbo_mode {
	struct morse_cmd_header hdr;
	__le32 aid;
	u8 enabled;
} __packed;

/**
 * struct morse_cmd_resp_turbo_mode - response message for TURBO_MODE
 */
struct morse_cmd_resp_turbo_mode {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_set_modulation - request message for SET_MODULATION
 * @mcs_index: MCS index (ie 0-10)
 *
 * Deprecated do not use
 */
struct morse_cmd_req_set_modulation {
	struct morse_cmd_header hdr;
	__le32 mcs_index;
} __packed;

/**
 * struct morse_cmd_resp_set_modulation - response message for SET_MODULATION
 *
 * Deprecated do not use
 */
struct morse_cmd_resp_set_modulation {
	struct morse_cmd_header hdr;
	__le32 status;
} __packed;

/**
 * struct morse_cmd_req_connect_deprecated - request message for CONNECT_DEPRECATED
 * @auth_type: Authentication type to use when connecting. See @ref enum morse_cmd_connect_auth_type
 * @ssid_len: Length of @ref ssid
 * @ssid: SSID to connect to
 * @sae_pwd_len: Length of @ref sae_pwd
 * @sae_pwd: Password to use for authentication, if @ref auth_type is @c CONNECT_AUTH_TYPE_SAE
 * @extra_assoc_ies_len: Length of @ref extra_assoc_ies
 * @extra_assoc_ies: Association IEs from host supplicant
 *
 * Deprecated. Use CONNECT.
 */
struct morse_cmd_req_connect_deprecated {
	struct morse_cmd_header hdr;
	u8 auth_type;
	u8 ssid_len;
	u8 ssid[MORSE_CMD_SSID_MAX_LEN];
	u8 __padding_0[3];
	u8 sae_pwd_len;
	u8 sae_pwd[MORSE_CMD_SAE_PASSWORD_MAX_LEN];
	u8 __padding_1[6];
	__le16 extra_assoc_ies_len;
	u8 extra_assoc_ies[];
} __packed;

#endif	//_MORSE_COMMANDS_H_
